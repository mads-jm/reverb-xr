<!DOCTYPE html>
<html>
<head>
    <!-- A-Frame already includes Three.js, so we don't need to load it separately -->
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-extras@6.1.0/dist/aframe-extras.min.js"></script>
    <!-- Directly include critical visualizer components to prevent loading issues -->
    <script>
        // Detect if we're in production or development - make this global
        window.isProduction = window.location.hostname !== 'localhost';
        
        // Adjust script base path based on environment
        // Updated to use a more reliable path for production
        const scriptBase = window.isProduction ? '/src/scripts/' : '../scripts/';
        
        // Log environment information
        console.log(`Running in ${window.isProduction ? 'production' : 'development'} mode`);
        console.log(`Using script base path: ${scriptBase}`);
        
        // Create script element with appropriate path
        const wave3Script = document.createElement('script');
        wave3Script.src = scriptBase + 'visualizers/wave3-script.js';
        wave3Script.onerror = (e) => {
            console.error('Failed to load wave3-script.js', e);
            // Fallback to alternative path if the first attempt fails
            const fallbackPath = '/scripts/visualizers/wave3-script.js';
            console.log(`Attempting fallback path: ${fallbackPath}`);
            wave3Script.src = fallbackPath;
        };
        document.head.appendChild(wave3Script);
    </script>
    <!-- Camera script will be loaded dynamically to ensure proper path resolution -->
    
    <!-- Regular scripts - these don't use import/export -->
    <script>
        // Use a dynamic script loader with path resolution
        function loadScript(path) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                // Fix path resolution for iframe/webpack context
                // When in /stages/home.html, we need to go up one level for script paths
                let scriptSrc = path;
                
                // Use the global isProduction
                // const isProduction = window.location.hostname !== 'localhost';
                
                if (path.startsWith('/')) {
                    // Use absolute path from root - this is what we want
                    scriptSrc = path;
                } else if (path.startsWith('./')) {
                    // Handle relative paths from current page correctly
                    const baseUrl = window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/'));
                    scriptSrc = baseUrl + path.substring(1);
                } else if (path.startsWith('../') && window.isProduction) {
                    // Convert relative paths to absolute in production
                    scriptSrc = '/' + path.substring(3);
                }
                
                // For debugging
                console.log('Loading script from:', scriptSrc);
                
                script.src = scriptSrc;
                script.onload = resolve;
                script.onerror = (e) => {
                    console.error('Failed to load script:', scriptSrc, e);
                    reject(e);
                };
                document.head.appendChild(script);
            });
        }
        
        // Load scripts after path resolver is ready
        document.addEventListener('DOMContentLoaded', async () => {
            // Output debug info about A-Frame component registry
            console.log('A-Frame loaded, available components:', Object.keys(AFRAME.components));
            
            // Load in sequence to respect dependencies
            try {
                // When the page is served at /stages/home.html, we need to go up a level
                // Don't use leading slash as it depends on where the page is served from
                await loadScript('../scripts/camera.js');
                console.log('Camera script loaded');
                
                await loadScript('../scripts/visualizers/visualizer.js');
                console.log('Visualizer base script loaded');
                
                // wave3-script.js is already loaded via direct script tag, no need to load again
                // await loadScript('../scripts/visualizers/wave3-script.js');
                console.log('Wave3 script already loaded via direct script tag');
                
                // Now that the wave3 script is loaded, we can register the component
                if (window.registerWave3Visualizer) {
                    try {
                        const registered = window.registerWave3Visualizer();
                        console.log('Wave3 visualizer component registration ' + (registered ? 'successful' : 'failed'));
                    } catch (err) {
                        console.error('Error registering Wave3 visualizer:', err);
                    }
                } else {
                    console.error('registerWave3Visualizer function not found! Check that scripts loaded in the correct order.');
                }
                
                // Initialize visualizers once all scripts are loaded
                if (window.initializeVisualizers) {
                    window.initializeVisualizers();
                }
            } catch (error) {
                console.error('Error loading scripts:', error);
            }
        });
    </script>

    <!-- Separate module script for the audio processors -->
    <script type="module">
        // Import the path resolver and audio processors as modules with webpack compatible paths
        let resolvePath, GPUAudioProcessor, AudioProcessor;
        
        // Use the global isProduction variable
        // const isProduction = window.location.hostname !== 'localhost';
        
        // Build paths based on environment
        const pathPrefix = window.isProduction ? '' : '../';
        const modulePath = window.isProduction ? '/src/scripts/' : '../scripts/';
        
        try {
            console.log('Starting dynamic imports');
            
            // Use Promise.all to ensure all modules are loaded before proceeding
            Promise.all([
                import(`${modulePath}utils/pathResolver.js`).then(module => {
                    resolvePath = module.resolvePath;
                    console.log('PathResolver loaded successfully');
                    return module;
                }).catch(err => console.error('Failed to load pathResolver:', err)),
                
                import(`${modulePath}audio/GPUAudioProcessor.js`).then(module => {
                    GPUAudioProcessor = module.GPUAudioProcessor;
                    console.log('GPUAudioProcessor loaded successfully');
                    return module;
                }).catch(err => console.error('Failed to load GPUAudioProcessor:', err)),
                
                import(`${modulePath}audio/AudioProcessor.js`).then(module => {
                    AudioProcessor = module.AudioProcessor;
                    console.log('AudioProcessor loaded successfully');
                    return module;
                }).catch(err => console.error('Failed to load AudioProcessor:', err))
            ]).then(modules => {
                console.log('All modules loaded successfully');
                
                // Now initialize the GPU audio processor now that it's defined
                initializeAudioProcessor();
                
                // Set up communication with parent window
                window.addEventListener('message', handleMessage);
                
                // Signal to parent that we're ready
                window.parent.postMessage({ type: 'visualizer-ready' }, '*');
            }).catch(error => {
                console.error('Error loading modules:', error);
                
                // Attempt to fallback to traditional script loading
                console.log('Attempting fallback script loading method...');
                loadFallbackScripts();
            });
            
            console.log('Dynamic imports initiated');
        } catch (error) {
            console.error('Error setting up dynamic imports:', error);
            
            // Attempt fallback loading method
            loadFallbackScripts();
        }
        
        // Fallback script loading method
        function loadFallbackScripts() {
            const scriptUrls = [
                '/src/scripts/utils/pathResolver.js',
                '/src/scripts/audio/AudioProcessor.js',
                '/src/scripts/audio/GPUAudioProcessor.js'
            ];
            
            Promise.all(scriptUrls.map(url => {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = url;
                    script.type = 'text/javascript';
                    script.onload = resolve;
                    script.onerror = (e) => {
                        console.error(`Failed to load ${url}`, e);
                        // Try another path format
                        const altUrl = url.replace('/src/scripts/', '/scripts/');
                        console.log(`Trying alternative URL: ${altUrl}`);
                        script.src = altUrl;
                        script.onerror = reject;
                    };
                    document.head.appendChild(script);
                });
            })).then(() => {
                console.log('Fallback scripts loaded');
                // Try to initialize with mock data after a delay to ensure scripts are processed
                setTimeout(() => {
                    initializeAudioProcessor();
                }, 1000);
            }).catch(err => {
                console.error('Error loading fallback scripts:', err);
            });
        }
        
        // Initialize the audio processor after modules are loaded
        function initializeAudioProcessor() {
            if (typeof GPUAudioProcessor === 'undefined') {
                console.error('GPUAudioProcessor is still not defined. Cannot initialize.');
                
                // Create a basic mock if needed
                window.gpuAudioProcessor = createBasicMockProcessor();
                console.log('Created basic mock processor');
                return;
            }
            
            try {
                // Create a global reference to the processor
                window.gpuAudioProcessor = new GPUAudioProcessor({
                    fftSize: 2048,
                    smoothingTimeConstant: 0.8,
                    debugMode: true
                });
                
                // Check if initMockData exists before calling it
                if (typeof window.gpuAudioProcessor.initMockData === 'function') {
                    window.gpuAudioProcessor.initMockData().then(() => {
                        console.log('GPUAudioProcessor initialized with mock data');
                    }).catch(err => {
                        console.error('Error initializing mock data:', err);
                        // Create fallback mock data
                        createMockData();
                    });
                } else {
                    console.warn('initMockData method not found on GPUAudioProcessor, creating mock data manually');
                    createMockData();
                }
                
                console.log('GPUAudioProcessor initialized');
            } catch (error) {
                console.error('Error initializing GPUAudioProcessor:', error);
                
                // Create a basic mock if needed
                window.gpuAudioProcessor = createBasicMockProcessor();
            }
        }
        
        // Create mock frequency and time domain data for visualization
        function createMockData() {
            if (!window.gpuAudioProcessor) return;
            
            console.log('Creating manual mock data');
            
            // Create flat data (silent)
            const frequencyDataSize = 1024;
            const timeDomainDataSize = 1024;
            
            const frequencyData = new Float32Array(frequencyDataSize);
            const timeDomainData = new Float32Array(timeDomainDataSize);
            
            // Set all values to silence to prevent static noise
            // For frequency data, -100 dB (minimum)
            frequencyData.fill(-100.0);
            
            // For time domain data, 0 (center line, no amplitude)
            timeDomainData.fill(0.0);
            
            // Attach these to the processor
            if (!window.gpuAudioProcessor.getFrequencyData) {
                window.gpuAudioProcessor.getFrequencyData = () => frequencyData;
            } else {
                const actualFrequencyData = window.gpuAudioProcessor.getFrequencyData();
                if (actualFrequencyData && actualFrequencyData.fill) {
                    actualFrequencyData.fill(-100.0);
                }
            }
            
            if (!window.gpuAudioProcessor.getTimeDomainData) {
                window.gpuAudioProcessor.getTimeDomainData = () => timeDomainData;
            } else {
                const actualTimeDomainData = window.gpuAudioProcessor.getTimeDomainData();
                if (actualTimeDomainData && actualTimeDomainData.fill) {
                    actualTimeDomainData.fill(0.0);
                }
            }
            
            // Add a method to get time domain data for API compatibility
            if (!window.gpuAudioProcessor.getTimeDomainDataForAPI) {
                window.gpuAudioProcessor.getTimeDomainDataForAPI = () => {
                    const apiData = new Uint8Array(timeDomainDataSize);
                    apiData.fill(128); // 128 is the center line (silent)
                    return apiData;
                };
            }
            
            // Add an updateTextureData method if it doesn't exist
            if (!window.gpuAudioProcessor.updateTextureData) {
                window.gpuAudioProcessor.updateTextureData = () => {
                    console.log('Mock updateTextureData called');
                };
            }
            
            console.log('Manual mock data created successfully');
        }
        
        // Create a basic mock processor when real one fails
        function createBasicMockProcessor() {
            console.log('Creating basic mock processor');
            
            const frequencyDataSize = 1024;
            const timeDomainDataSize = 1024;
            
            const frequencyData = new Float32Array(frequencyDataSize);
            const timeDomainData = new Float32Array(timeDomainDataSize);
            
            // Set all values to silence
            frequencyData.fill(-100.0);
            timeDomainData.fill(0.0);
            
            return {
                getFrequencyData: () => frequencyData,
                getTimeDomainData: () => timeDomainData,
                getTimeDomainDataForAPI: () => {
                    const apiData = new Uint8Array(timeDomainDataSize);
                    apiData.fill(128); // 128 is the center line (silent)
                    return apiData;
                },
                updateTextureData: () => {
                    // console.log('Mock updateTextureData called');
                },
                initMockData: () => Promise.resolve(),
                stop: () => console.log('Mock stop called')
            };
        }
        
        // Track when visualizers are loaded
        window.visualizersLoaded = true;
        console.log('Visualizer scripts loaded');
        
        // Add toggleElement function globally
        function toggleElement(elementType, visible) {
            console.log(`Toggle ${elementType}: ${visible}`);
            
            try {
                const elements = {
                    wave3: document.querySelector('[wave3-visualizer]'),
                    waveform: document.querySelector('[circular-waveform]'),
                    bars: document.querySelector('[frequency-bars]'),
                    skybox: document.querySelector('a-sky'),
                    lights: Array.from(document.querySelectorAll('a-light')),
                    ground: document.querySelector('#ground-plane')
                };
                
                const element = elements[elementType];
                
                if (!element) {
                    console.warn(`Element ${elementType} not found`);
                    return;
                }
                
                if (Array.isArray(element)) {
                    // Handle arrays of elements (e.g. lights)
                    element.forEach(el => {
                        if (el) {
                            el.setAttribute('visible', visible);
                        }
                    });
                } else {
                    // Handle single elements
                    element.setAttribute('visible', visible);
                }
                
                console.log(`Set visibility of ${elementType} to ${visible}`);
            } catch (error) {
                console.error(`Error toggling ${elementType}:`, error);
            }
        }
        
        // Make toggleElement globally available
        window.toggleElement = toggleElement;
        
        // Handle messages from parent window
        function handleMessage(event) {
            // Make sure message is from parent window
            if (event.source !== window.parent) return;
            
            const message = event.data;
            
            // Handle different message types
            switch (message.type) {
                case 'frequencyData':
                case 'timeDomainData':
                    if (window.gpuAudioProcessor) {
                        // Update the audio processor with data from parent
                        updateProcessorData(message.type, message.data);
                    }
                    break;
                    
                case 'init-audio':
                    // Parent is telling us to initialize audio
                    if (window.gpuAudioProcessor) {
                        // Stop any current processing
                        if (typeof window.gpuAudioProcessor.stop === 'function') {
                            window.gpuAudioProcessor.stop();
                        }
                        
                        // Tell the processor entity to use the GPU processor
                        const processorEntity = document.getElementById('audio-processor');
                        if (processorEntity) {
                            processorEntity.gpuAudioProcessor = window.gpuAudioProcessor;
                            
                            // Emit event that the processor is ready
                            processorEntity.emit('audio-processor-ready');
                        }
                    }
                    break;
                
                case 'toggle':
                    // Handle toggle message via the toggle handler
                    const elementType = message.element;
                    const visible = message.visible;
                    toggleElement(elementType, visible);
                    break;
            }
        }
        
        // Update the GPU processor with data from parent
        function updateProcessorData(type, data) {
            if (!window.gpuAudioProcessor) return;
            
            try {
                // Map the data to the appropriate texture in the GPU processor
                if (type === 'frequencyData') {
                    // Make sure data exists and has the correct type
                    if (!data || !data.length) {
                        console.warn('Invalid frequency data received');
                        return;
                    }
                    
                    // Convert Uint8Array to Float32Array for GPU processing
                    const floatData = new Float32Array(data.length);
                    for (let i = 0; i < data.length; i++) {
                        // Convert from 0-255 to -100-0 dB range
                        // Add value validation to prevent NaN or extreme values
                        const value = data[i];
                        if (isNaN(value) || value < 0 || value > 255) {
                            floatData[i] = -100.0; // Default to silence for invalid values
                        } else {
                            floatData[i] = (value / 255.0 * 100.0) - 100.0;
                        }
                    }
                    
                    // Update frequency data in GPU processor
                    const frequencyData = window.gpuAudioProcessor.getFrequencyData();
                    if (frequencyData && frequencyData.set) {
                        frequencyData.set(floatData);
                    }
                } else if (type === 'timeDomainData') {
                    // Make sure data exists and has the correct type
                    if (!data || !data.length) {
                        console.warn('Invalid time domain data received');
                        return;
                    }
                    
                    // Convert Uint8Array to Float32Array for GPU processing
                    const floatData = new Float32Array(data.length);
                    for (let i = 0; i < data.length; i++) {
                        // Convert from 0-255 to -1.0-1.0 range
                        // Add value validation to prevent NaN or extreme values
                        const value = data[i];
                        if (isNaN(value) || value < 0 || value > 255) {
                            floatData[i] = 0.0; // Default to center line for invalid values
                        } else {
                            floatData[i] = (value / 128.0) - 1.0;
                        }
                    }
                    
                    // Update time domain data in GPU processor
                    const timeDomainData = window.gpuAudioProcessor.getTimeDomainData();
                    if (timeDomainData && timeDomainData.set) {
                        timeDomainData.set(floatData);
                    }
                }
                
                // Force update on the textures if the method exists
                if (typeof window.gpuAudioProcessor.updateTextureData === 'function') {
                    window.gpuAudioProcessor.updateTextureData();
                }
                
                // Also update the audio-processor entity for components that use the old system
                const processorEntity = document.getElementById('audio-processor');
                if (processorEntity) {
                    let timeDomainDataForEvent = data;
                    
                    // If we need to generate time domain data and we have a method for it
                    if (type === 'frequencyData' && typeof window.gpuAudioProcessor.getTimeDomainDataForAPI === 'function') {
                        timeDomainDataForEvent = window.gpuAudioProcessor.getTimeDomainDataForAPI();
                    }
                    
                    // Emit the update event with the data
                    processorEntity.emit('audiodata-updated', {
                        frequencyData: type === 'frequencyData' ? data : new Uint8Array(data.length).fill(0),
                        timeDomainData: type === 'timeDomainData' ? data : timeDomainDataForEvent
                    });
                }
            } catch (error) {
                console.error('Error updating processor data:', error);
                // Don't rethrow to prevent breaking the visualization loop
            }
        }

        // Add this to better handle initialization
        document.addEventListener('DOMContentLoaded', () => {
            // Check if A-Frame is loaded
            if (AFRAME.scenes.length) {
                initializeVisualizers();
            } else {
                // Wait for A-Frame to initialize
                document.querySelector('a-scene').addEventListener('loaded', initializeVisualizers);
            }
        });
        
        function initializeVisualizers() {
            console.log('Initializing visualizers');
            console.log('Current A-Frame components:', Object.keys(AFRAME.components));
            console.log('Wave3 component registered:', AFRAME.components['wave3-visualizer'] ? 'Yes' : 'No');
            
            // Try to ensure the wave3 component is properly registered before initializing
            if (!AFRAME.components['wave3-visualizer'] && window.registerWave3Visualizer) {
                console.log('Attempting to register wave3-visualizer component again...');
                try {
                    window.registerWave3Visualizer();
                    console.log('Registration result:', AFRAME.components['wave3-visualizer'] ? 'Success' : 'Failed');
                } catch (err) {
                    console.error('Error during manual registration:', err);
                }
            }
            
            // Check if the component is already initialized and working
            const wave3Entity = document.getElementById('wave3-visualizer');
            if (wave3Entity && AFRAME.components['wave3-visualizer']) {
                console.log('Wave3 visualizer component is already registered and initialized');
                // Force a refresh of the component's data without removing it
                try {
                    // Get the current component data
                    const componentData = wave3Entity.getAttribute('wave3-visualizer');
                    console.log('Current wave3 visualizer data:', componentData);
                    
                    // Update some property to trigger a refresh (if needed)
                    // For example, slightly adjust a numeric value
                    if (typeof componentData === 'object') {
                        // Create a copy of the data with a small modification
                        const refreshedData = Object.assign({}, componentData);
                        if (refreshedData.height) {
                            // Store original height
                            const originalHeight = refreshedData.height;
                            // Temporarily change height to force refresh
                            refreshedData.height = originalHeight * 1.001;
                            wave3Entity.setAttribute('wave3-visualizer', refreshedData);
                            
                            // Restore original height after a short delay
                            setTimeout(() => {
                                refreshedData.height = originalHeight;
                                wave3Entity.setAttribute('wave3-visualizer', refreshedData);
                                console.log('Wave3 visualizer refreshed');
                            }, 100);
                        }
                    }
                } catch (error) {
                    console.error('Error refreshing wave3 visualizer:', error);
                }
            } else if (wave3Entity) {
                console.warn('Wave3 visualizer entity exists but component is not registered properly');
                // Try registering again
                if (window.registerWave3Visualizer) {
                    window.registerWave3Visualizer();
                }
            } else {
                console.warn('Wave3 visualizer entity not found in the DOM');
            }
        }
    </script>
    <script>
        // Register audio processor component to handle data from parent window
        // This is kept for backward compatibility with existing components
        AFRAME.registerComponent('audio-processor', {
            init: function() {
                console.log('Audio processor initialized');
                this.frequencyData = new Uint8Array(128);
                this.timeDomainData = new Uint8Array(128);
                this.el.emit('audio-processor-ready');
                
                // Listen for messages from parent window if we're not using the GPU processor
                if (!window.gpuAudioProcessor) {
                    window.addEventListener('message', this.handleMessage.bind(this));
                }
            },
            
            handleMessage: function(event) {
                // Make sure message is from the parent window
                if (event.source !== window.parent) return;
                
                // Process the received audio data
                if (event.data.type === 'frequencyData' || event.data.type === 'timeDomainData') {
                    this.updateData(event.data.type, event.data.data);
                }
            },
            
            updateData: function(type, data) {
                if (type === 'frequencyData') {
                    this.frequencyData = data;
                } else if (type === 'timeDomainData') {
                    this.timeDomainData = data;
                }
                // Emit an event that the visualizer can listen for
                this.el.emit('audiodata-updated', {
                    frequencyData: this.frequencyData,
                    timeDomainData: this.timeDomainData
                });
            },
            
            getFrequencyData: function() {
                return this.frequencyData;
            },
            
            getTimeDomainData: function() {
                return this.timeDomainData;
            }
        });

        // Register circular waveform component
        AFRAME.registerComponent('circular-waveform', {
            schema: {
                analyserNode: { type: 'selector' },
                radius: { type: 'number', default: 5 },
                height: { type: 'number', default: 2 },
                color: { type: 'color', default: '#FFF' },
                segments: { type: 'int', default: 128 }
            },
            
            init: function() {
                console.log('Circular waveform initialized');
                this.analyserNode = this.data.analyserNode;
                
                // Create geometry
                this.createGeometry();
                
                // Listen for audio data updates
                this.analyserNode.addEventListener('audiodata-updated', this.updateWaveform.bind(this));
            },
            
            createGeometry: function() {
                // Create a circle of points
                const segments = this.data.segments;
                const radius = this.data.radius;
                
                // Create geometry
                const geometry = new THREE.BufferGeometry();
                
                // Create positions array
                const positions = new Float32Array(segments * 3);
                const colors = new Float32Array(segments * 3);
                
                // Initialize positions in a circle
                for (let i = 0; i < segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    const x = Math.cos(angle) * radius;
                    const y = 0;
                    const z = Math.sin(angle) * radius;
                    
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;
                    
                    // Rainbow colors
                    const hue = i / segments;
                    const color = new THREE.Color().setHSL(hue, 1, 0.5);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                // Create material
                const material = new THREE.LineBasicMaterial({
                    color: this.data.color,
                    vertexColors: true,
                    linewidth: 2
                });
                
                // Create line
                this.line = new THREE.LineLoop(geometry, material);
                this.el.setObject3D('mesh', this.line);
                
                // Store reference to position attribute for updates
                this.positions = geometry.attributes.position;
            },
            
            updateWaveform: function(event) {
                if (!this.positions) return;
                
                const timeDomainData = event.detail.timeDomainData;
                const segments = this.data.segments;
                const radius = this.data.radius;
                const height = this.data.height;
                
                // Update positions based on audio data
                for (let i = 0; i < segments; i++) {
                    const dataIndex = Math.floor((i / segments) * timeDomainData.length);
                    const value = timeDomainData[dataIndex] / 128.0 - 1.0; // Convert to -1 to 1 range
                    
                    const angle = (i / segments) * Math.PI * 2;
                    const amplifiedValue = value * height;
                    
                    // Calculate new position
                    const newRadius = radius + amplifiedValue;
                    const x = Math.cos(angle) * newRadius;
                    const y = amplifiedValue * 0.5; // Add some vertical movement
                    const z = Math.sin(angle) * newRadius;
                    
                    // Update position
                    this.positions.array[i * 3] = x;
                    this.positions.array[i * 3 + 1] = y;
                    this.positions.array[i * 3 + 2] = z;
                }
                
                // Mark positions for update
                this.positions.needsUpdate = true;
            }
        });

        // Register frequency bars component
        AFRAME.registerComponent('frequency-bars', {
            schema: {
                analyserNode: { type: 'selector' },
                radius: { type: 'number', default: 8 },
                height: { type: 'number', default: 3 },
                color: { type: 'color', default: '#FFF' },
                segments: { type: 'int', default: 64 },
                smoothing: { type: 'number', default: 0.8 }
            },
            
            init: function() {
                console.log('Frequency bars initialized');
                this.analyserNode = this.data.analyserNode;
                this.averages = new Array(this.data.segments).fill(0);
                
                // Create geometry
                this.createGeometry();
                
                // Listen for audio data updates
                this.analyserNode.addEventListener('audiodata-updated', this.updateBars.bind(this));
            },
            
            createGeometry: function() {
                const segments = this.data.segments;
                const radius = this.data.radius;
                
                // Create a group to hold all the bars
                this.barGroup = new THREE.Group();
                this.el.setObject3D('mesh', this.barGroup);
                
                // Create individual bars
                this.bars = [];
                
                for (let i = 0; i < segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    
                    // Create bar geometry
                    const barWidth = 2 * Math.PI * radius / segments * 0.9; // 90% of available space
                    const barDepth = 0.5;
                    const geometry = new THREE.BoxGeometry(barWidth, 1, barDepth);
                    
                    // Create material with gradient color
                    const hue = i / segments;
                    const color = new THREE.Color().setHSL(hue, 1, 0.5);
                    const material = new THREE.MeshStandardMaterial({
                        color: color,
                        metalness: 0.3,
                        roughness: 0.7,
                        emissive: color,
                        emissiveIntensity: 0.3,
                        transparent: true, // Make fully opaque
                        opacity: 0.25
                    });
                    
                    // Create mesh
                    const bar = new THREE.Mesh(geometry, material);
                    
                    // Position the bar at the perimeter, on the ground
                    bar.position.set(x, 0, z);
                    
                    // Rotate to face center
                    bar.lookAt(0, 0, 0);
                    
                    // Set the pivot point to the bottom of the bar
                    bar.geometry.translate(0, 0.5, 0);
                    
                    // Add to group
                    this.barGroup.add(bar);
                    this.bars.push(bar);
                }
            },
            
            updateBars: function(event) {
                if (!this.bars || !this.bars.length) return;
                
                // Use time domain data (amplitude)
                const timeDomainData = event.detail.timeDomainData;
                const segments = this.data.segments;
                const maxHeight = this.data.height;
                const smoothing = this.data.smoothing;
                
                // Update each bar based on amplitude data
                for (let i = 0; i < segments; i++) {
                    // Map bar index to time domain data index
                    const dataIndex = Math.floor((i / segments) * timeDomainData.length);
                    
                    // Get amplitude value (0-255) and normalize to 0-1
                    const value = timeDomainData[dataIndex] / 255.0;
                    
                    // Apply smoothing for rolling average
                    this.averages[i] = this.averages[i] * smoothing + value * (1 - smoothing);
                    
                    // Update bar height by scaling only the Y axis
                    const height = this.averages[i] * maxHeight;
                    this.bars[i].scale.y = Math.max(0.01, height); // Ensure minimum height
                    
                    // Update color intensity based on value
                    const material = this.bars[i].material;
                    material.emissiveIntensity = 0.3 + this.averages[i] * 0.7;
                }
            }
        });
        
        // Add toggle handler component to scene
        AFRAME.registerComponent('toggle-handler', {
            init: function() {
                console.log('Toggle handler initializing...');
                // Listen for messages from parent window
                window.addEventListener('message', this.handleMessage.bind(this));
                
                // Wait for DOM to be fully loaded
                setTimeout(() => {
                    // Store references to elements
                    this.elements = {
                        wave3: document.querySelector('[wave3-visualizer]'),
                        waveform: document.querySelector('[circular-waveform]'),
                        bars: document.querySelector('[frequency-bars]'),
                        skybox: document.querySelector('a-sky'),
                        lights: Array.from(document.querySelectorAll('a-light')),
                        ground: document.querySelector('#ground-plane')
                    };
                    
                    // Log found elements for debugging
                    console.log('Toggle handler initialized with elements:', {
                        wave3: !!this.elements.wave3,
                        waveform: !!this.elements.waveform,
                        bars: !!this.elements.bars,
                        skybox: !!this.elements.skybox,
                        lights: this.elements.lights.length,
                        ground: !!this.elements.ground
                    });
                    
                    // Start animation loop to continuously send data
                    this.startAnimationLoop();
                }, 500);
            },
            
            // Handle all message types from parent window
            handleMessage: function(event) {
                // Make sure message is from the parent window
                if (event.source !== window.parent) return;
                
                // Process different message types
                if (event.data.type === 'toggle') {
                    this.handleToggleMessage(event.data);
                } else if (event.data.type === 'audiodata') {
                    this.handleAudioDataMessage(event.data);
                }
            },
            
            // Handle toggle message for visibility
            handleToggleMessage: function(data) {
                const elementType = data.element;
                const visible = data.visible;
                
                console.log(`Toggle ${elementType}: ${visible}`);
                
                switch(elementType) {
                    case 'waveform':
                        this.toggleElement(this.elements.waveform, visible);
                        break;
                    case 'bars':
                        this.toggleElement(this.elements.bars, visible);
                        break;
                    case 'wave3':
                        this.toggleElement(this.elements.wave3, visible);
                        break;
                    case 'skybox':
                        this.toggleElement(this.elements.skybox, visible);
                        break;
                    case 'lights':
                        if (this.elements.lights) {
                            this.elements.lights.forEach(light => 
                                this.toggleElement(light, visible)
                            );
                        }
                        break;
                    case 'ground':
                        this.toggleElement(this.elements.ground, visible);
                        break;
                }
            },
            
            // Start animation loop to continuously send data
            startAnimationLoop: function() {
                let animationFrame = 0;
                
                const animate = () => {
                    animationFrame++;
                    
                    // Continue animation
                    this.animationFrame = requestAnimationFrame(animate);
                };
                
                // Start animation loop
                this.animationFrame = requestAnimationFrame(animate);
                console.log('Started animation loop for continuous data');
            },
            
            toggleElement: function(element, visible) {
                if (!element) {
                    console.warn('Attempted to toggle undefined element');
                    return;
                }
                
                element.setAttribute('visible', visible);
                console.log(`Set visibility of ${element.id || element.tagName} to ${visible}`);
            }
        });

        // Ensure the component is registered when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, registering wave3 visualizer component');
            
            // First, try to register the component
            if (window.registerWave3Visualizer) {
                try {
                    const result = window.registerWave3Visualizer();
                    console.log('Initial Wave3 visualizer registration:', result ? 'successful' : 'failed');
                } catch (err) {
                    console.error('Error during initial Wave3 visualizer registration:', err);
                }
            } else {
                console.error('registerWave3Visualizer not found in global scope. Script may not have loaded correctly.');
            }
            
            // Wait for the A-Frame scene to be loaded before checking component
            const scene = document.querySelector('a-scene');
            if (scene) {
                if (scene.hasLoaded) {
                    console.log('Scene already loaded');
                    ensureWave3Visualizer();
                } else {
                    console.log('Waiting for scene to load');
                    scene.addEventListener('loaded', ensureWave3Visualizer);
                }
            } else {
                console.error('No A-Frame scene found in the document');
            }
            
            // Function to ensure wave3 visualizer is properly initialized
            function ensureWave3Visualizer() {
                console.log('Ensuring wave3 visualizer is initialized after scene load');
                
                // Check if the component is registered
                if (!AFRAME.components['wave3-visualizer'] && window.registerWave3Visualizer) {
                    console.log('Registering wave3-visualizer after scene load');
                    window.registerWave3Visualizer();
                }
                
                // Get the wave3 entity
                const wave3Entity = document.getElementById('wave3-visualizer');
                if (wave3Entity) {
                    console.log('Found wave3 entity in DOM');
                    
                    // Make sure it has the component
                    if (!wave3Entity.components['wave3-visualizer'] && AFRAME.components['wave3-visualizer']) {
                        console.log('Adding wave3-visualizer component to entity');
                        
                        // Get the original attributes from the HTML
                        const componentData = wave3Entity.getAttribute('wave3-visualizer');
                        console.log('Component data:', componentData);
                        
                        // Re-add the component
                        wave3Entity.setAttribute('wave3-visualizer', componentData);
                    }
                } else {
                    console.warn('Wave3 visualizer entity not found in the DOM');
                }
            }
        });

    </script>
</head>

<body>
    <a-scene id="scene" renderer="antialias: true; colorManagement: true;" toggle-handler>
        <!-- Assets -->
        <a-assets>
            <img id="skyTexture" src="https://cdn.aframe.io/a-painter/images/sky.jpg">
        </a-assets>
        
        <!-- Camera -->       
        <a-entity custom-camera position="0 0 0"></a-entity>
        
        <!-- Audio processor entity -->
        <a-entity id="audio-processor" audio-processor></a-entity>
        
        <!-- Wave3 traditional visualizer - line-based version -->
        <a-entity
            id="wave3-visualizer" 
            position="0 5 0"
            wave3-visualizer="
                audioProcessor: #audio-processor;
                width: 4;
                height: 10;
                radius: 20;
                segments: 128;
                lineWidth: 3;
                colorStart: #ff3232;
                colorMiddle: #32ffff;
                colorEnd: #3232ff;
            ">
        </a-entity>
        
        <!-- Circular waveform visualizer -->
        <a-entity 
            position="0 1.0 0"
            circular-waveform="
                analyserNode: #audio-processor;
                radius: 10;
                height: 4;
                color: #ffffff;
                segments: 128;
            ">
        </a-entity>
        
        <!-- Frequency bars visualizer -->
        <a-entity 
            position="0 0 0"
            frequency-bars="
                analyserNode: #audio-processor;
                radius: 25;
                height: 25;
                segments: 256;
                smoothing: 0.8;
            ">
        </a-entity>
        
        <!-- Environment -->
        <a-sky src="#skyTexture" height="2048" radius="30" theta-length="90" width="2048" position="0 -2 0"></a-sky>
        <a-light type="ambient" intensity="0.1"></a-light> 
        <a-light type="directional" position="1 1 1" intensity="0.1"></a-light>
        
        <!-- Ground plane with reflection -->
        <a-entity 
            id="ground-plane"
            geometry="primitive: plane; width: 100; height: 100" 
            position="0 0 0" 
            rotation="-90 0 0" 
            material="shader: standard; color: #333; metalness: 0.3; roughness: 0.2; reflectivity: 0.5"
        ></a-entity>
    </a-scene>
<script src="/home.bundle.js"></script></body>
</html> 