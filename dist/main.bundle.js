/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles/main.css":
/*!*******************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles/main.css ***!
  \*******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `/* ====== VARIABLES ====== */\r\n:root {\r\n  /* Colors */\r\n  --bg-color: #282c34;\r\n  --text-color: white;\r\n  --accent-color: #1DB954; /* Spotify green */\r\n  --accent-hover: #1ed760;\r\n  --border-color: rgba(255, 255, 255, 0.2);\r\n  --panel-bg: rgba(0, 0, 0, 0.7);\r\n  --control-bg: #444;\r\n  --control-hover: #555;\r\n  --disabled-bg: #333;\r\n  --disabled-text: #666;\r\n  \r\n  /* Spacing */\r\n  --spacing-xs: 2px;\r\n  --spacing-sm: 5px;\r\n  --spacing-md: 10px;\r\n  --spacing-lg: 20px;\r\n}\r\n\r\n/* ====== BASE STYLES ====== */\r\nbody {\r\n  font-family: Arial, Helvetica, sans-serif;\r\n  background-color: var(--bg-color);\r\n  color: var(--text-color);\r\n  margin: 0;\r\n  display: flex;\r\n  height: 100vh;\r\n}\r\n\r\nh1, h2, h3, h4, h5, h6 {\r\n  margin-top: 0;\r\n}\r\n\r\n#aframe-iframe {\r\n  width: 100%;\r\n  height: 100vh;\r\n  border: none;\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n}\r\n\r\n/* ====== CONTROL PANEL ====== */\r\n.control-panel {\r\n  position: absolute;\r\n  top: 10px;\r\n  left: 10px;\r\n  background-color: var(--panel-bg);\r\n  color: var(--text-color);\r\n  padding: var(--spacing-md);\r\n  border-radius: 5px;\r\n  z-index: 100;\r\n  width: 250px;\r\n  max-height: 90vh;\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n\r\n/* Panel Header */\r\n.panel-header {\r\n  display: flex;\r\n  justify-content: space-between;\r\n  align-items: flex-start;\r\n  cursor: pointer;\r\n  margin-bottom: var(--spacing-md);\r\n  flex-shrink: 0;\r\n}\r\n\r\n.header-text {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: flex-start;\r\n}\r\n\r\n.header-text h2 {\r\n  margin: 0;\r\n  font-size: 18px;\r\n  line-height: 1.2;\r\n}\r\n\r\n.header-text h3 {\r\n  margin: 0;\r\n  font-size: 16px;\r\n  font-weight: normal;\r\n  line-height: 1.2;\r\n}\r\n\r\n.version-text {\r\n  margin: 2px 0 0 0;\r\n  font-size: 12px;\r\n  color: #aaa;\r\n  font-style: italic;\r\n}\r\n\r\n/* Panel Content */\r\n.panel-content {\r\n  overflow-y: auto;\r\n  overflow-x: hidden;\r\n  transition: max-height 0.3s ease;\r\n  max-height: calc(90vh - 60px);\r\n  scrollbar-width: thin;\r\n  scrollbar-color: rgba(255, 255, 255, 0.3) transparent;\r\n}\r\n\r\n.panel-content.collapsed {\r\n  max-height: 0;\r\n  overflow: hidden;\r\n}\r\n\r\n/* Custom scrollbar */\r\n.panel-content::-webkit-scrollbar {\r\n  width: 6px;\r\n}\r\n\r\n.panel-content::-webkit-scrollbar-track {\r\n  background: transparent;\r\n}\r\n\r\n.panel-content::-webkit-scrollbar-thumb {\r\n  background-color: rgba(255, 255, 255, 0.3);\r\n  border-radius: 3px;\r\n}\r\n\r\n/* Control Groups */\r\n.control-group {\r\n  margin-bottom: var(--spacing-md);\r\n  padding: var(--spacing-sm);\r\n  border-bottom: 1px solid var(--border-color);\r\n}\r\n\r\n.control-group h3 {\r\n  margin: 0 0 5px 0;\r\n  font-size: 14px;\r\n}\r\n\r\n.toggle-item {\r\n  display: flex;\r\n  align-items: center;\r\n  margin: 5px 0;\r\n  flex-wrap: nowrap;\r\n}\r\n\r\n.toggle-item label {\r\n  margin-left: 5px;\r\n  font-size: 14px;\r\n  white-space: nowrap;\r\n}\r\n\r\n/* ====== BUTTONS ====== */\r\n/* Base button styles */\r\n.control-button, .small-button, .play-pause-button {\r\n  border-radius: 20px;\r\n  cursor: pointer;\r\n  border: none;\r\n  color: var(--text-color);\r\n  transition: all 0.2s ease;\r\n}\r\n\r\n/* Control buttons (large) */\r\n.control-button {\r\n  background-color: var(--control-bg);\r\n  border: 1px solid #555;\r\n  padding: 6px 12px;\r\n  margin: 0 5px;\r\n  font-size: 14px;\r\n}\r\n\r\n.control-button:hover {\r\n  background-color: var(--control-hover);\r\n  transform: scale(1.05);\r\n}\r\n\r\n.control-button:active {\r\n  transform: scale(0.95);\r\n}\r\n\r\n/* Small action buttons */\r\n.small-button {\r\n  margin-left: var(--spacing-md);\r\n  padding: 2px 5px;\r\n  font-size: 12px;\r\n  background-color: var(--control-bg);\r\n}\r\n\r\n.small-button:hover {\r\n  background-color: var(--control-hover);\r\n}\r\n\r\n.small-button:disabled {\r\n  background-color: var(--disabled-bg);\r\n  color: var(--disabled-text);\r\n  cursor: not-allowed;\r\n}\r\n\r\n/* Accent buttons (green) */\r\n.play-pause-button, #demo-track-button, #spotify-play-pause, #start-system-audio {\r\n  background-color: var(--accent-color);\r\n  border: 1px solid var(--accent-color);\r\n  padding: 6px 12px;\r\n  font-size: 16px;\r\n}\r\n\r\n.play-pause-button:hover, #demo-track-button:hover, #spotify-play-pause:hover, #start-system-audio:hover {\r\n  background-color: var(--accent-hover);\r\n  box-shadow: 0 0 10px rgba(29, 185, 84, 0.5);\r\n  transform: scale(1.05);\r\n}\r\n\r\n.play-pause-button:active, #demo-track-button:active, #spotify-play-pause:active, #start-system-audio:active {\r\n  transform: scale(0.95);\r\n}\r\n\r\n/* Demo track button and playback controls */\r\n.demo-button-container {\r\n  display: flex;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n  margin-bottom: 12px;\r\n  padding-bottom: 8px;\r\n  border-bottom: 1px dashed var(--border-color);\r\n}\r\n\r\n#demo-track-button {\r\n  background-color: var(--accent-color);\r\n  border-color: var(--accent-color);\r\n  color: white;\r\n  padding: 6px 12px;\r\n  border-radius: 20px;\r\n  cursor: pointer;\r\n  font-size: 14px;\r\n  transition: all 0.2s ease;\r\n  text-align: center;\r\n  border: 1px solid var(--accent-color);\r\n  flex-grow: 1;\r\n  margin-right: 10px;\r\n}\r\n\r\n#demo-track-button:hover {\r\n  background-color: var(--accent-hover);\r\n  box-shadow: 0 0 10px rgba(29, 185, 84, 0.5);\r\n  transform: scale(1.05);\r\n}\r\n\r\n#demo-track-button:active {\r\n  transform: scale(0.95);\r\n}\r\n\r\n/* Now playing section */\r\n.now-playing-container {\r\n  display: flex;\r\n  flex-direction: column;\r\n  margin-bottom: 10px;\r\n  padding: 5px;\r\n  background-color: rgba(0, 0, 0, 0.2);\r\n  border-radius: 4px;\r\n}\r\n\r\n.now-playing-label {\r\n  font-size: 12px;\r\n  color: #aaa;\r\n  margin-bottom: 3px;\r\n}\r\n\r\n.now-playing-text {\r\n  font-size: 14px;\r\n  font-weight: bold;\r\n  white-space: nowrap;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n}\r\n\r\n/* Playback controls */\r\n#playback-controls {\r\n  margin-bottom: var(--spacing-md);\r\n  width: 100%;\r\n}\r\n\r\n.controls-container {\r\n  display: flex;\r\n  align-items: center;\r\n  width: 100%;\r\n  background-color: var(--control-bg);\r\n  border-radius: 20px;\r\n  overflow: hidden;\r\n}\r\n\r\n.play-pause-button {\r\n  margin: 0;\r\n  min-width: 36px;\r\n  border-radius: 20px 0 0 20px;\r\n}\r\n\r\n/* Volume and sensitivity controls */\r\n.volume-control, .sensitivity-control {\r\n  display: flex;\r\n  align-items: center;\r\n  padding: 0 8px;\r\n  flex-grow: 1;\r\n  height: 100%;\r\n}\r\n\r\n.controls-row {\r\n  display: flex;\r\n  align-items: center;\r\n  margin-top: 8px;\r\n  padding: 5px 8px;\r\n  background-color: var(--control-bg);\r\n  border-radius: 20px;\r\n}\r\n\r\n.controls-row label {\r\n  margin-right: 8px;\r\n  font-size: 12px;\r\n  white-space: nowrap;\r\n  color: var(--text-color);\r\n  min-width: 80px;\r\n}\r\n\r\n.sensitivity-control {\r\n  display: flex;\r\n  align-items: center;\r\n  flex-grow: 1;\r\n}\r\n\r\n.volume-icon, .sensitivity-icon {\r\n  margin-right: 8px;\r\n}\r\n\r\ninput[type=\"range\"] {\r\n  width: 100%;\r\n  -webkit-appearance: none;\r\n  appearance: none;\r\n  height: 5px;\r\n  background: rgba(255, 255, 255, 0.3);\r\n  border-radius: 2px;\r\n}\r\n\r\ninput[type=\"range\"]::-webkit-slider-thumb {\r\n  -webkit-appearance: none;\r\n  appearance: none;\r\n  width: 15px;\r\n  height: 15px;\r\n  border-radius: 50%;\r\n  background: var(--accent-color);\r\n  cursor: pointer;\r\n}\r\n\r\ninput[type=\"range\"]::-moz-range-thumb {\r\n  width: 15px;\r\n  height: 15px;\r\n  border-radius: 50%;\r\n  background: var(--accent-color);\r\n  cursor: pointer;\r\n  border: none;\r\n}\r\n\r\n/* ====== INPUTS ====== */\r\n/* File input */\r\n.file-input-container {\r\n  display: flex;\r\n  align-items: center;\r\n  margin-left: 5px;\r\n  flex-wrap: nowrap;\r\n  max-width: 180px;\r\n}\r\n\r\n#file-input {\r\n  width: 0.1px;\r\n  height: 0.1px;\r\n  opacity: 0;\r\n  overflow: hidden;\r\n  position: absolute;\r\n  z-index: -1;\r\n}\r\n\r\n.file-input-label {\r\n  cursor: pointer;\r\n  background-color: var(--control-bg);\r\n  color: var(--text-color);\r\n  padding: 2px 8px;\r\n  border-radius: 3px;\r\n  font-size: 12px;\r\n  white-space: nowrap;\r\n  min-width: 60px;\r\n  text-align: center;\r\n}\r\n\r\n.file-input-label:hover {\r\n  background-color: var(--control-hover);\r\n}\r\n\r\n/* ====== NOW PLAYING ====== */\r\n.audio-controls {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  margin-top: var(--spacing-md);\r\n  width: 100%;\r\n}\r\n\r\n/* ====== SPOTIFY SECTION ====== */\r\n#spotify-controls {\r\n  margin-top: var(--spacing-md);\r\n}\r\n\r\n#spotify-now-playing {\r\n  margin: 5px 0;\r\n  padding: 8px;\r\n  background-color: rgba(30, 215, 96, 0.1);\r\n  border-radius: 5px;\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n}\r\n\r\n#spotify-status {\r\n  font-size: 12px;\r\n  color: #aaa;\r\n  margin-bottom: 5px;\r\n}\r\n\r\n#spotify-track-name {\r\n  font-weight: bold;\r\n  margin-bottom: 3px;\r\n}\r\n\r\n#spotify-track-artist {\r\n  font-size: 12px;\r\n  color: #aaa;\r\n}\r\n\r\n#spotify-controls-buttons {\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  margin: 10px 0;\r\n  width: 100%;\r\n}\r\n\r\n#spotify-play-pause {\r\n  padding: 8px 16px;\r\n  font-size: 18px;\r\n}\r\n\r\n.spotify-note {\r\n  font-size: 12px;\r\n  color: #aaa;\r\n  text-align: center;\r\n  margin-top: var(--spacing-md);\r\n}\r\n\r\n#spotify-album-art {\r\n  width: 50px;\r\n  height: 50px;\r\n  margin: 3px 0;\r\n}\r\n\r\n#system-audio-container {\r\n  margin-top: 5px;\r\n  padding-top: 5px;\r\n  border-top: 1px dashed var(--border-color);\r\n}\r\n\r\n#system-audio-container label {\r\n  color: var(--accent-color);\r\n}\r\n\r\n/* ====== MODAL DIALOG ====== */\r\n.modal {\r\n  display: none;\r\n  position: fixed;\r\n  z-index: 1000;\r\n  left: 0;\r\n  top: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  background-color: rgba(0, 0, 0, 0.7);\r\n}\r\n\r\n.modal-content {\r\n  background-color: #1e1e2e;\r\n  color: #cdd6f4;\r\n  margin: 15% auto;\r\n  padding: 20px;\r\n  border: 1px solid #7f849c;\r\n  border-radius: 8px;\r\n  width: 80%;\r\n  max-width: 500px;\r\n  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);\r\n}\r\n\r\n.close-modal {\r\n  color: #aaa;\r\n  float: right;\r\n  font-size: 28px;\r\n  font-weight: bold;\r\n  cursor: pointer;\r\n}\r\n\r\n.close-modal:hover,\r\n.close-modal:focus {\r\n  color: #cba6f7;\r\n  text-decoration: none;\r\n}\r\n\r\n.modal h3 {\r\n  margin-top: 0;\r\n  color: #cba6f7;\r\n}\r\n\r\n.modal input[type=\"text\"] {\r\n  width: 100%;\r\n  padding: 10px;\r\n  margin: 10px 0 20px 0;\r\n  border-radius: 4px;\r\n  border: 1px solid #7f849c;\r\n  background-color: #313244;\r\n  color: #cdd6f4;\r\n  box-sizing: border-box;\r\n}\r\n\r\n.modal-buttons {\r\n  display: flex;\r\n  justify-content: flex-end;\r\n}\r\n\r\n.modal-buttons button {\r\n  margin-left: 10px;\r\n  padding: 8px 16px;\r\n  border: none;\r\n  border-radius: 4px;\r\n  background-color: #89b4fa;\r\n  color: #1e1e2e;\r\n  cursor: pointer;\r\n}\r\n\r\n.modal-buttons button:hover {\r\n  background-color: #b4befe;\r\n}\r\n\r\n/* ====== RESPONSIVE STYLES ====== */\r\n@media (max-height: 700px) {\r\n  .control-panel {\r\n    max-height: 85vh;\r\n  }\r\n  \r\n  .panel-content {\r\n    max-height: calc(85vh - 60px);\r\n  }\r\n  \r\n  .control-group {\r\n    margin-bottom: 5px;\r\n    padding: 3px;\r\n  }\r\n  \r\n  #spotify-album-art {\r\n    width: 40px;\r\n    height: 40px;\r\n  }\r\n  \r\n  .spotify-note p {\r\n    margin: 5px 0;\r\n  }\r\n}\r\n\r\n@media (max-height: 500px) {\r\n  .control-panel {\r\n    width: 220px;\r\n  }\r\n  \r\n  .header-text h2 {\r\n    font-size: 16px;\r\n  }\r\n  \r\n  .header-text h3 {\r\n    font-size: 14px;\r\n  }\r\n  \r\n  .control-group h3 {\r\n    font-size: 13px;\r\n  }\r\n  \r\n  .toggle-item label {\r\n    font-size: 12px;\r\n  }\r\n}\r\n\r\n/* ====== VISUALIZATION MODAL ====== */\r\n.full-width {\r\n  width: 100%;\r\n  margin: 0;\r\n}\r\n\r\n.viz-modal-content {\r\n  max-width: 600px;\r\n  max-height: 80vh;\r\n  overflow-y: auto;\r\n}\r\n\r\n.modal-header {\r\n  display: flex;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n  margin-bottom: 15px;\r\n  padding-bottom: 10px;\r\n  border-bottom: 1px solid var(--border-color);\r\n}\r\n\r\n.modal-header h3 {\r\n  margin: 0;\r\n  color: var(--accent-color);\r\n}\r\n\r\n.modal-body {\r\n  overflow-y: auto;\r\n}\r\n\r\n.modal-body .control-group {\r\n  background-color: rgba(0, 0, 0, 0.2);\r\n  border-radius: 5px;\r\n  padding: 10px;\r\n  margin-bottom: 15px;\r\n}\r\n\r\n.modal-body .control-group h3 {\r\n  color: var(--accent-color);\r\n  margin-top: 0;\r\n  margin-bottom: 10px;\r\n  font-size: 16px;\r\n}\r\n\r\n.modal-body .toggle-item {\r\n  padding: 5px 0;\r\n}\r\n\r\n/* ====== ENHANCED MODAL STYLES ====== */\r\n.modal {\r\n  display: none;\r\n  position: fixed;\r\n  z-index: 1000;\r\n  left: 0;\r\n  top: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  background-color: rgba(0, 0, 0, 0.7);\r\n  overflow: auto;\r\n  animation: fadeIn 0.3s;\r\n}\r\n\r\n.modal-content {\r\n  background-color: #1e1e2e;\r\n  color: #cdd6f4;\r\n  margin: 5% auto;\r\n  padding: 20px;\r\n  border: 1px solid #7f849c;\r\n  border-radius: 8px;\r\n  width: 80%;\r\n  max-width: 500px;\r\n  box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);\r\n  animation: slideIn 0.3s;\r\n  position: relative;\r\n}\r\n\r\n@keyframes fadeIn {\r\n  from { opacity: 0; }\r\n  to { opacity: 1; }\r\n}\r\n\r\n@keyframes slideIn {\r\n  from { transform: translateY(-50px); opacity: 0; }\r\n  to { transform: translateY(0); opacity: 1; }\r\n}\r\n\r\n.close-modal {\r\n  color: #aaa;\r\n  font-size: 28px;\r\n  font-weight: bold;\r\n  cursor: pointer;\r\n  transition: color 0.2s;\r\n}\r\n\r\n.close-modal:hover,\r\n.close-modal:focus {\r\n  color: var(--accent-color);\r\n  text-decoration: none;\r\n}\r\n\r\n/* ====== VISUALIZATION CONTROL PANEL ====== */\r\n.viz-control-panel {\r\n  position: absolute;\r\n  top: calc(10px + var(--spacing-md) + var(--spacing-md));\r\n  right: 10px;\r\n  background-color: var(--panel-bg);\r\n  color: var(--text-color);\r\n  padding: var(--spacing-md);\r\n  border-radius: 5px;\r\n  z-index: 100;\r\n  width: 250px;\r\n  max-height: 90vh;\r\n  display: flex;\r\n  flex-direction: column;\r\n  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);\r\n}\r\n\r\n.viz-panel-header {\r\n  display: flex;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n  cursor: pointer;\r\n  margin-bottom: var(--spacing-md);\r\n  flex-shrink: 0;\r\n  padding-bottom: var(--spacing-sm);\r\n  border-bottom: 1px solid var(--border-color);\r\n}\r\n\r\n.viz-panel-header h3 {\r\n  margin: 0;\r\n  font-size: 16px;\r\n  line-height: 1.2;\r\n  color: var(--accent-color);\r\n}\r\n\r\n.viz-toggle-icon {\r\n  font-size: 14px;\r\n  transition: transform 0.3s ease;\r\n}\r\n\r\n.viz-panel-content {\r\n  overflow-y: auto;\r\n  overflow-x: hidden;\r\n  transition: max-height 0.3s ease;\r\n  max-height: calc(90vh - 60px);\r\n  scrollbar-width: thin;\r\n  scrollbar-color: rgba(255, 255, 255, 0.3) transparent;\r\n}\r\n\r\n.viz-panel-content.collapsed {\r\n  max-height: 0;\r\n  overflow: hidden;\r\n}\r\n\r\n/* Reusing existing scrollbar styles */\r\n.viz-panel-content::-webkit-scrollbar {\r\n  width: 6px;\r\n}\r\n\r\n.viz-panel-content::-webkit-scrollbar-track {\r\n  background: transparent;\r\n}\r\n\r\n.viz-panel-content::-webkit-scrollbar-thumb {\r\n  background-color: rgba(255, 255, 255, 0.3);\r\n  border-radius: 3px;\r\n}\r\n\r\n/* Media queries for responsive design */\r\n@media (max-width: 768px) {\r\n  .viz-control-panel {\r\n    left: 10px;\r\n    top: auto;\r\n    bottom: 10px;\r\n    width: calc(100% - 40px);\r\n    max-height: 40vh;\r\n  }\r\n} `, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://reverb-xr/./src/styles/main.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://reverb-xr/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://reverb-xr/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://reverb-xr/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://reverb-xr/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://reverb-xr/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://reverb-xr/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://reverb-xr/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://reverb-xr/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _styles_main_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles/main.css */ \"./src/styles/main.css\");\n/* harmony import */ var _scripts_utils_pathResolver_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scripts/utils/pathResolver.js */ \"./src/scripts/utils/pathResolver.js\");\n/* harmony import */ var _scripts_audio_GPUAudioProcessor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scripts/audio/GPUAudioProcessor.js */ \"./src/scripts/audio/GPUAudioProcessor.js\");\n/* harmony import */ var _scripts_audio_AudioProcessor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scripts/audio/AudioProcessor.js */ \"./src/scripts/audio/AudioProcessor.js\");\n/* harmony import */ var _scripts_audio_SpotifyProcessor_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scripts/audio/SpotifyProcessor.js */ \"./src/scripts/audio/SpotifyProcessor.js\");\n/* harmony import */ var _scripts_external_spotify_sdk_loader_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scripts/external/spotify-sdk-loader.js */ \"./src/scripts/external/spotify-sdk-loader.js\");\n// Import styles\n\n\n// Import utility modules\n\n\n// Import audio processors\n\n\n\n\n\n/**\r\n * Main application controller for audio visualization\r\n * Handles UI interactions, audio source selection, and visualization data processing\r\n */\ndocument.addEventListener('DOMContentLoaded', () => {\n  // Make path resolver globally available\n  window.resolvePath = _scripts_utils_pathResolver_js__WEBPACK_IMPORTED_MODULE_1__.resolvePath;\n\n  // ====== INITIALIZATION ======\n\n  /**\r\n   * Initialize the audio processor with configuration\r\n   * @type {GPUAudioProcessor}\r\n   */\n  const audioProcessor = new _scripts_audio_GPUAudioProcessor_js__WEBPACK_IMPORTED_MODULE_2__.GPUAudioProcessor({\n    debugMode: true,\n    // Enable debugging initially\n    fftSize: 1024,\n    // Reduced size for better performance\n    smoothingTimeConstant: 0.6 // Less smoothing for more responsive visuals\n  });\n\n  // DOM element references\n  const micOption = document.getElementById('mic-option');\n  const fileOption = document.getElementById('file-option');\n  const urlOption = document.getElementById('url-option');\n  const spotifyOption = document.getElementById('spotify-option');\n  const systemAudioOption = document.getElementById('system-audio-option');\n  const systemAudioContainer = document.getElementById('system-audio-container');\n  const startMicButton = document.getElementById('start-mic');\n  const startSystemAudioButton = document.getElementById('start-system-audio');\n  const fileInput = document.getElementById('file-input');\n  const openUrlModalButton = document.getElementById('open-url-modal');\n  const urlModal = document.getElementById('url-modal');\n  const urlInput = document.getElementById('url-input');\n  const playUrlButton = document.getElementById('play-url-button');\n  const cancelUrlButton = document.getElementById('cancel-url-button');\n  const closeModalButton = document.querySelector('.close-modal');\n  const demoTrackButton = document.getElementById('demo-track-button');\n  const playPauseButton = document.getElementById('play-pause-button');\n  const playbackControls = document.getElementById('playback-controls');\n  const dataOutput = document.getElementById('data-output');\n  const aframeIframe = document.getElementById('aframe-iframe');\n  const spotifyControls = document.getElementById('spotify-controls');\n  const spotifyLogin = document.getElementById('spotify-login');\n  const nowPlaying = document.getElementById('now-playing');\n\n  // Lazy loading variables for Spotify\n  let spotifyProcessor = null;\n  let spotifySDKLoaded = false;\n\n  // Track current audio state\n  let isAudioPlaying = false;\n  let currentAudioType = null; // 'demo', 'file', 'url', 'mic', etc.\n  let currentUrlAudio = null;\n\n  // Demo track URL\n  const DEMO_TRACK_URL = 'https://cdn.pixabay.com/audio/2025/01/09/audio_ebb251db8d.mp3';\n\n  // Set the iframe source using the path resolver\n  if (aframeIframe) {\n    aframeIframe.src = (0,_scripts_utils_pathResolver_js__WEBPACK_IMPORTED_MODULE_1__.resolvePath)('stages/home.html');\n  }\n\n  // ====== AUDIO SOURCE SELECTION ======\n\n  /**\r\n   * Handle microphone selection\r\n   */\n  micOption.addEventListener('change', () => {\n    if (micOption.checked) {\n      switchAudioSource('mic');\n    }\n  });\n\n  /**\r\n   * Handle file input selection\r\n   */\n  fileOption.addEventListener('change', () => {\n    if (fileOption.checked) {\n      switchAudioSource('file');\n    }\n  });\n\n  /**\r\n   * Handle URL input selection\r\n   */\n  urlOption.addEventListener('change', () => {\n    if (urlOption.checked) {\n      switchAudioSource('url');\n    }\n  });\n\n  /**\r\n   * Handle Spotify selection\r\n   */\n  spotifyOption.addEventListener('change', () => {\n    if (spotifyOption.checked) {\n      switchAudioSource('spotify');\n    }\n  });\n\n  /**\r\n   * Handle system audio selection\r\n   */\n  systemAudioOption.addEventListener('change', () => {\n    if (systemAudioOption.checked) {\n      switchAudioSource('system');\n    }\n  });\n\n  /**\r\n   * Handle opening URL modal\r\n   */\n  openUrlModalButton.addEventListener('click', () => {\n    urlModal.style.display = 'block';\n    urlInput.focus();\n  });\n\n  /**\r\n   * Handle URL modal close button\r\n   */\n  closeModalButton.addEventListener('click', () => {\n    urlModal.style.display = 'none';\n  });\n\n  /**\r\n   * Handle URL modal cancel button\r\n   */\n  cancelUrlButton.addEventListener('click', () => {\n    urlModal.style.display = 'none';\n  });\n\n  /**\r\n   * Close the modal when clicking outside of it\r\n   */\n  window.addEventListener('click', event => {\n    if (event.target === urlModal) {\n      urlModal.style.display = 'none';\n    }\n  });\n\n  // ====== AUDIO CONTROL BUTTONS ======\n\n  /**\r\n   * Handle microphone start button click\r\n   */\n  startMicButton.addEventListener('click', async () => {\n    try {\n      await audioProcessor.initMicrophone();\n      nowPlaying.textContent = 'Microphone (Visualization Only)';\n      currentAudioType = 'mic';\n      // Microphone doesn't need play/pause control\n      removePlayPauseControl();\n      console.log(\"Microphone initialized for visualization only\");\n\n      // Optionally alert the user that the microphone is for visualization only\n      if (!localStorage.getItem('micAlertShown')) {\n        alert('Microphone is used for visualization only. Audio output is muted to prevent feedback.');\n        localStorage.setItem('micAlertShown', 'true');\n      }\n    } catch (error) {\n      console.error('Error initializing microphone:', error);\n      nowPlaying.textContent = 'Microphone error';\n      alert('Could not access microphone: ' + error.message);\n    }\n  });\n\n  /**\r\n   * Handle system audio start button click\r\n   */\n  startSystemAudioButton.addEventListener('click', async () => {\n    try {\n      showSystemAudioInstructions();\n      await audioProcessor.initMicrophone();\n      nowPlaying.textContent = 'System Audio (Visualization Only)';\n      currentAudioType = 'system';\n      // System audio doesn't need play/pause control\n      removePlayPauseControl();\n      console.log(\"System audio capture initialized for visualization only\");\n\n      // Make it clear that this is for visualization only\n      alert('System audio capture is enabled for visualization only. The audio from your system will not be played back through the browser to prevent feedback.');\n    } catch (error) {\n      console.error('Error starting system audio capture:', error);\n      nowPlaying.textContent = 'System Audio error';\n      alert('Error: ' + error.message);\n    }\n  });\n\n  /**\r\n   * Handle file selection\r\n   */\n  fileInput.addEventListener('change', async () => {\n    const file = fileInput.files[0];\n    if (file) {\n      // Stop previous source first\n      if (audioProcessor.isActive) {\n        audioProcessor.stop();\n      }\n      await audioProcessor.initFile(file);\n      nowPlaying.textContent = file.name;\n\n      // Update audio state\n      isAudioPlaying = true;\n      currentAudioType = 'file';\n\n      // Add play/pause control\n      addPlayPauseControl();\n      console.log(\"File initialized:\", file.name);\n    }\n  });\n\n  /**\r\n   * Handle demo track button click\r\n   */\n  demoTrackButton.addEventListener('click', () => {\n    switchAudioSource('demo');\n  });\n\n  /**\r\n   * Handle URL play button click\r\n   */\n  playUrlButton.addEventListener('click', async () => {\n    const url = urlInput.value.trim();\n    if (url) {\n      // Stop previous source first\n      if (audioProcessor.isActive) {\n        audioProcessor.stop();\n      }\n      try {\n        // For URL audio, we need to create a File object from the URL\n        const response = await fetch(url);\n        const arrayBuffer = await response.arrayBuffer();\n        const blob = new Blob([arrayBuffer], {\n          type: response.headers.get('content-type')\n        });\n        const file = new File([blob], url.split('/').pop(), {\n          type: blob.type\n        });\n        await audioProcessor.initFile(file);\n        urlModal.style.display = 'none';\n        nowPlaying.textContent = 'URL: ' + url.substring(0, 30) + (url.length > 30 ? '...' : '');\n\n        // Update audio state\n        isAudioPlaying = true;\n        currentAudioType = 'url';\n        currentUrlAudio = url;\n\n        // Add play/pause control\n        addPlayPauseControl();\n        console.log(\"URL audio initialized:\", url);\n      } catch (error) {\n        console.error('Error playing audio from URL:', error);\n        alert('Error loading audio: ' + error.message);\n      }\n    }\n  });\n\n  // ====== AUDIO DATA PROCESSING ======\n\n  /**\r\n   * Continuously send audio data to A-Frame for visualization\r\n   * Called recursively with requestAnimationFrame\r\n   */\n  function sendAudioDataToAFrame() {\n    // Force the analyzer to update data by calling these methods\n    const frequencyData = audioProcessor.getFrequencyDataForAPI();\n    const timeDomainData = audioProcessor.getTimeDomainDataForAPI();\n\n    // Print summary stats occasionally\n    if (Math.random() < 0.01) {\n      // ~1% of frames\n      const freqStats = calculateStats(frequencyData);\n      console.log(\"Sending frequency data stats:\", freqStats);\n    }\n\n    // Send to iframe if it's loaded\n    if (aframeIframe.contentWindow) {\n      aframeIframe.contentWindow.postMessage({\n        type: 'frequencyData',\n        data: frequencyData\n      }, '*');\n      aframeIframe.contentWindow.postMessage({\n        type: 'timeDomainData',\n        data: timeDomainData\n      }, '*');\n    }\n    requestAnimationFrame(sendAudioDataToAFrame);\n  }\n\n  /**\r\n   * Calculate statistics for audio data arrays\r\n   * @param {Uint8Array} data - The audio data array\r\n   * @returns {Object} Object containing min, max, avg, and nonZeroPercent stats\r\n   */\n  function calculateStats(data) {\n    if (!data || data.length === 0) return {\n      min: 0,\n      max: 0,\n      avg: 0\n    };\n    let min = 255,\n      max = 0,\n      sum = 0;\n    for (let i = 0; i < data.length; i++) {\n      min = Math.min(min, data[i]);\n      max = Math.max(max, data[i]);\n      sum += data[i];\n    }\n    return {\n      min,\n      max,\n      avg: (sum / data.length).toFixed(2),\n      nonZeroPercent: (data.filter(v => v > 0).length / data.length * 100).toFixed(1) + '%'\n    };\n  }\n\n  // ====== UI MANAGEMENT HELPERS ======\n\n  /**\r\n   * Update UI for microphone mode\r\n   */\n  function updateUIForMicrophoneMode() {\n    startMicButton.disabled = false;\n    startSystemAudioButton.disabled = true;\n    fileInput.disabled = true;\n    openUrlModalButton.disabled = true;\n    spotifyControls.style.display = 'none';\n    systemAudioContainer.style.display = 'none';\n\n    // Stop any currently active audio\n    if (audioProcessor.isActive) {\n      audioProcessor.stop();\n    }\n\n    // Show the now playing container\n    document.querySelector('.now-playing-container').style.display = 'flex';\n\n    // Microphone input doesn't use play/pause control\n    removePlayPauseControl();\n\n    // Reset audio state\n    isAudioPlaying = false;\n    currentAudioType = null;\n  }\n\n  /**\r\n   * Update UI for file input mode\r\n   */\n  function updateUIForFileMode() {\n    fileInput.disabled = false;\n    openUrlModalButton.disabled = true;\n    startMicButton.disabled = true;\n    startSystemAudioButton.disabled = true;\n    spotifyControls.style.display = 'none';\n    systemAudioContainer.style.display = 'none';\n\n    // If audio is currently playing, stop it\n    if (audioProcessor.isActive) {\n      audioProcessor.stop();\n      isAudioPlaying = false;\n      currentAudioType = null;\n    }\n\n    // Show the now playing container\n    document.querySelector('.now-playing-container').style.display = 'flex';\n\n    // File mode starts with no file, so no play/pause control initially\n    removePlayPauseControl();\n  }\n\n  /**\r\n   * Update UI for URL input mode\r\n   */\n  function updateUIForUrlMode() {\n    openUrlModalButton.disabled = false;\n    startMicButton.disabled = true;\n    startSystemAudioButton.disabled = true;\n    fileInput.disabled = true;\n    spotifyControls.style.display = 'none';\n    systemAudioContainer.style.display = 'none';\n\n    // If audio is currently playing and not URL, stop it\n    if (audioProcessor.isActive && currentAudioType !== 'url') {\n      audioProcessor.stop();\n      isAudioPlaying = false;\n    }\n\n    // Show the now playing container\n    document.querySelector('.now-playing-container').style.display = 'flex';\n\n    // If we have a URL loaded and that was our previous source, restore the play/pause button\n    if (currentUrlAudio && currentAudioType === 'url') {\n      addPlayPauseControl();\n    } else {\n      removePlayPauseControl();\n      currentAudioType = null;\n    }\n  }\n\n  /**\r\n   * Update UI for Spotify mode\r\n   */\n  function updateUIForSpotifyMode() {\n    // Only load Spotify components when needed\n    loadSpotifyComponents();\n    showSpotifyControls();\n\n    // Show system audio option when Spotify is selected but hide the radio button\n    systemAudioContainer.style.display = 'flex';\n    systemAudioOption.style.display = 'none'; // Hide the radio button\n    systemAudioOption.disabled = true; // Disable it to prevent interactions\n    startSystemAudioButton.disabled = false; // Enable the start button\n\n    // Make the label text clearer since there's no radio button\n    const systemAudioLabel = document.querySelector('label[for=\"system-audio-option\"]');\n    if (systemAudioLabel) {\n      systemAudioLabel.textContent = \"Capture System Audio:\";\n    }\n    startMicButton.disabled = true;\n    fileInput.disabled = true;\n    openUrlModalButton.disabled = true;\n\n    // If audio is currently playing, stop it\n    if (audioProcessor.isActive) {\n      audioProcessor.stop();\n      isAudioPlaying = false;\n      currentAudioType = null;\n    }\n\n    // Hide the now playing container\n    document.querySelector('.now-playing-container').style.display = 'none';\n\n    // Spotify has its own controls\n    removePlayPauseControl();\n  }\n\n  /**\r\n   * Update UI for system audio mode\r\n   */\n  function updateUIForSystemAudioMode() {\n    startSystemAudioButton.disabled = false;\n    startMicButton.disabled = true;\n    fileInput.disabled = true;\n    openUrlModalButton.disabled = true;\n\n    // If audio is currently playing, stop it\n    if (audioProcessor.isActive) {\n      audioProcessor.stop();\n      isAudioPlaying = false;\n      currentAudioType = null;\n    }\n\n    // System audio doesn't need play/pause control\n    removePlayPauseControl();\n  }\n\n  /**\r\n   * Show instructions for system audio capture\r\n   */\n  function showSystemAudioInstructions() {\n    alert('Please play music on Spotify and make sure your microphone can capture system audio.\\n\\n' + 'On Windows: Enable \"Stereo Mix\" in sound settings\\n' + 'On Mac: Use Soundflower or BlackHole\\n' + 'On mobile: Place device near speakers');\n  }\n\n  // ====== VISUALIZATION CONTROLS ======\n\n  /**\r\n   * Set up toggle controls for visualization elements\r\n   */\n  function setupToggleControls() {\n    // Function to send toggle commands to iframe\n    function toggleElement(elementType, visible) {\n      aframeIframe.contentWindow.postMessage({\n        type: 'toggle',\n        element: elementType,\n        visible: visible\n      }, '*');\n    }\n\n    // Set up event listeners for toggle controls\n    document.querySelectorAll('.toggle-control').forEach(control => {\n      control.addEventListener('change', function () {\n        toggleElement(this.dataset.element, this.checked);\n      });\n    });\n  }\n\n  // ====== SPOTIFY INTEGRATION ======\n\n  /**\r\n   * Load Spotify SDK and initialize components\r\n   */\n  function loadSpotifyComponents() {\n    // Only load the SDK once\n    if (!spotifySDKLoaded) {\n      // Use the SDK loader to properly handle webpack integration\n      (0,_scripts_external_spotify_sdk_loader_js__WEBPACK_IMPORTED_MODULE_5__.loadSpotifySDK)().then(() => {\n        console.log('Spotify Web Playback SDK loaded successfully');\n        spotifySDKLoaded = true;\n        initializeSpotifyProcessor();\n      }).catch(error => {\n        console.error('Failed to load Spotify SDK:', error);\n      });\n    } else if (!spotifyProcessor) {\n      // SDK already loaded, just initialize the processor\n      initializeSpotifyProcessor();\n    }\n  }\n\n  /**\r\n   * Initialize the Spotify processor and UI elements\r\n   */\n  function initializeSpotifyProcessor() {\n    // Only create the processor if it doesn't exist\n    if (!spotifyProcessor) {\n      // Get the singleton instance\n      spotifyProcessor = _scripts_audio_SpotifyProcessor_js__WEBPACK_IMPORTED_MODULE_4__.SpotifyProcessor.getInstance();\n\n      // Get references to DOM elements\n      const spotifyLogin = document.getElementById('spotify-login');\n      const spotifyPlayerContainer = document.getElementById('spotify-player-container');\n\n      // Check if elements exist before trying to access them\n      if (!spotifyLogin || !spotifyPlayerContainer) {\n        console.error('Spotify UI elements not found in the DOM');\n        return;\n      }\n\n      // Check if we have a valid token\n      if (spotifyProcessor.checkAuth()) {\n        spotifyLogin.style.display = 'none';\n        spotifyPlayerContainer.style.display = 'block';\n\n        // Connect to Spotify (initializes audio context)\n        spotifyProcessor.connectToSpotify();\n      } else {\n        spotifyLogin.style.display = 'block';\n        spotifyPlayerContainer.style.display = 'none';\n      }\n\n      // Set up event listeners\n      setupSpotifyEventListeners();\n\n      // Update the note about audio visualization\n      const spotifyNote = document.querySelector('.spotify-note p');\n      if (spotifyNote) {\n        spotifyNote.innerHTML = 'Start playing in your Spotify app, then control here!<br>' + '<strong>For visualization:</strong> Select \"System Audio\" option and click Start.';\n      }\n    }\n  }\n\n  /**\r\n   * Set up event listeners for Spotify controls\r\n   */\n  function setupSpotifyEventListeners() {\n    console.log('Setting up Spotify event listeners');\n\n    // Login button\n    const loginButton = document.getElementById('spotify-login');\n    if (loginButton) {\n      loginButton.removeEventListener('click', spotifyLoginHandler); // Remove any existing listeners\n      loginButton.addEventListener('click', spotifyLoginHandler);\n      console.log('Spotify login button listener attached');\n    }\n\n    // Play/Pause button\n    const playPauseButton = document.getElementById('spotify-play-pause');\n    if (playPauseButton) {\n      playPauseButton.addEventListener('click', () => {\n        console.log('Play/Pause clicked');\n        if (spotifyProcessor) {\n          spotifyProcessor.togglePlayback();\n        }\n      });\n    }\n\n    // Next track button\n    const nextButton = document.getElementById('spotify-next');\n    if (nextButton) {\n      nextButton.addEventListener('click', () => {\n        console.log('Next track clicked');\n        if (spotifyProcessor) {\n          spotifyProcessor.nextTrack();\n        }\n      });\n    }\n\n    // Previous track button\n    const prevButton = document.getElementById('spotify-prev');\n    if (prevButton) {\n      prevButton.addEventListener('click', () => {\n        console.log('Previous track clicked');\n        if (spotifyProcessor) {\n          spotifyProcessor.previousTrack();\n        }\n      });\n    }\n  }\n\n  /**\r\n   * Handle Spotify login button click\r\n   */\n  function spotifyLoginHandler() {\n    console.log('Spotify login button clicked');\n    if (spotifyProcessor) {\n      spotifyProcessor.authorize();\n    } else {\n      console.error('Spotify processor not initialized');\n    }\n  }\n\n  /**\r\n   * Show Spotify control UI\r\n   */\n  function showSpotifyControls() {\n    // Hide other controls\n    startMicButton.disabled = true;\n    fileInput.disabled = true;\n\n    // Show Spotify controls\n    spotifyControls.style.display = 'block';\n  }\n\n  /**\r\n   * Search for tracks on Spotify\r\n   * @returns {Promise<void>}\r\n   */\n  async function searchSpotify() {\n    if (!spotifyProcessor) return;\n    const query = document.getElementById('spotify-search').value.trim();\n    if (!query) return;\n    try {\n      const results = await spotifyProcessor.searchTracks(query);\n      displaySearchResults(results.tracks.items);\n    } catch (error) {\n      console.error('Error searching Spotify:', error);\n    }\n  }\n\n  /**\r\n   * Display Spotify search results\r\n   * @param {Array} tracks - Array of track objects from Spotify API\r\n   */\n  function displaySearchResults(tracks) {\n    const spotifyResults = document.getElementById('spotify-results');\n    const spotifyTrackName = document.getElementById('spotify-track-name');\n    spotifyResults.innerHTML = '';\n    tracks.forEach(track => {\n      const trackElement = document.createElement('div');\n      trackElement.className = 'track-result';\n      trackElement.innerHTML = `\n        <div class=\"track-info\">\n          <div class=\"track-name\">${track.name}</div>\n          <div class=\"track-artist\">${track.artists[0].name}</div>\n        </div>\n      `;\n      trackElement.addEventListener('click', () => {\n        spotifyProcessor.playTrack(track.uri);\n        spotifyTrackName.textContent = `${track.name} - ${track.artists[0].name}`;\n      });\n      spotifyResults.appendChild(trackElement);\n    });\n  }\n\n  // ====== APPLICATION STARTUP ======\n\n  // Start sending data\n  sendAudioDataToAFrame();\n\n  // Disable debug mode after 10 seconds to avoid console spam\n  setTimeout(() => {\n    audioProcessor.setDebugMode(false);\n    console.log(\"Debug mode disabled to reduce console output\");\n  }, 10000);\n\n  // Set up toggle controls\n  setupToggleControls();\n\n  // Set up event listener for play/pause button\n  playPauseButton.addEventListener('click', togglePlayPause);\n\n  /**\r\n   * Toggle play/pause for current audio\r\n   */\n  function togglePlayPause() {\n    console.log(\"Toggle play/pause clicked, current state:\", isAudioPlaying);\n    if (isAudioPlaying) {\n      audioProcessor.pause();\n      isAudioPlaying = false;\n    } else {\n      audioProcessor.play();\n      isAudioPlaying = true;\n    }\n    updatePlayPauseButton();\n  }\n\n  /**\r\n   * Update the play/pause button appearance\r\n   */\n  function updatePlayPauseButton() {\n    if (playPauseButton) {\n      playPauseButton.textContent = isAudioPlaying ? '' : '';\n      console.log(\"Updated play/pause button to:\", playPauseButton.textContent);\n    }\n  }\n\n  /**\r\n   * Add play/pause control to the UI\r\n   */\n  function addPlayPauseControl() {\n    // Show the playback controls\n    playbackControls.style.display = 'block';\n\n    // Update button state\n    updatePlayPauseButton();\n  }\n\n  /**\r\n   * Remove play/pause control from the UI\r\n   */\n  function removePlayPauseControl() {\n    playbackControls.style.display = 'none';\n  }\n\n  // Get reference to volume slider\n  const volumeSlider = document.getElementById('volume-slider');\n\n  /**\r\n   * Handle volume slider changes\r\n   */\n  volumeSlider.addEventListener('input', () => {\n    // Get volume from slider (0-100) and normalize to 0-1\n    const rawVolume = parseFloat(volumeSlider.value);\n    const volume = rawVolume / 100;\n\n    // Set volume on audio processor (which sets volume on its internal gain node)\n    audioProcessor.setVolume(volume);\n\n    // Update volume icon based on level\n    const volumeIcon = document.querySelector('.volume-icon');\n    if (volume === 0) {\n      volumeIcon.textContent = '';\n    } else if (volume < 0.5) {\n      volumeIcon.textContent = '';\n    } else {\n      volumeIcon.textContent = '';\n    }\n    console.log(\"Volume changed to:\", volume, \"(raw slider value:\", rawVolume, \")\");\n  });\n\n  /**\r\n   * Set initial volume on audio processor\r\n   */\n  audioProcessor.setVolume(1.0); // Set default volume\n\n  /**\r\n   * Switch to a new audio source, properly cleaning up the previous one\r\n   * @param {string} sourceType - Type of source to switch to ('mic', 'file', 'url', 'spotify', 'system', 'demo')\r\n   */\n  function switchAudioSource(sourceType) {\n    console.log(`Switching audio source to: ${sourceType}`);\n\n    // Stop the current source first\n    if (audioProcessor.isActive) {\n      audioProcessor.stop();\n    }\n\n    // Reset audio state\n    isAudioPlaying = false;\n\n    // Update current audio type\n    currentAudioType = sourceType;\n\n    // Reset UI elements based on new source type\n    resetUIForSourceSwitch();\n\n    // Apply source-specific UI updates\n    switch (sourceType) {\n      case 'mic':\n        updateUIForMicrophoneMode();\n        break;\n      case 'file':\n        updateUIForFileMode();\n        break;\n      case 'url':\n        updateUIForUrlMode();\n        break;\n      case 'spotify':\n        updateUIForSpotifyMode();\n        break;\n      case 'system':\n        updateUIForSystemAudioMode();\n        break;\n      case 'demo':\n        // Demo is a special case, we actually start playback immediately\n        playDemoTrack();\n        break;\n    }\n\n    // Ensure volume is set correctly\n    const volume = parseFloat(volumeSlider.value);\n    audioProcessor.setVolume(volume);\n    console.log(`Audio source switched to ${sourceType}`);\n  }\n\n  /**\r\n   * Reset all UI elements to a default state before switching sources\r\n   */\n  function resetUIForSourceSwitch() {\n    // Hide the playback controls by default\n    playbackControls.style.display = 'none';\n\n    // Reset the now playing text\n    nowPlaying.textContent = 'None';\n\n    // Ensure all input controls are disabled by default\n    startMicButton.disabled = true;\n    startSystemAudioButton.disabled = true;\n    fileInput.disabled = true;\n    openUrlModalButton.disabled = true;\n\n    // Hide Spotify controls\n    spotifyControls.style.display = 'none';\n\n    // Hide system audio container\n    systemAudioContainer.style.display = 'none';\n\n    // Show all radio buttons by default (we'll hide specific ones later if needed)\n    systemAudioOption.style.display = 'inline-block';\n\n    // Reset any custom label text\n    const systemAudioLabel = document.querySelector('label[for=\"system-audio-option\"]');\n    if (systemAudioLabel) {\n      systemAudioLabel.textContent = \"System Audio (via Mic)\";\n    }\n\n    // Show the now playing container\n    document.querySelector('.now-playing-container').style.display = 'flex';\n  }\n\n  /**\r\n   * Play the demo track\r\n   */\n  async function playDemoTrack() {\n    // Show that we're loading\n    nowPlaying.textContent = 'Loading Demo Track...';\n    try {\n      // For demo track, fetch the file and create a File object\n      const response = await fetch(DEMO_TRACK_URL);\n      const arrayBuffer = await response.arrayBuffer();\n      const blob = new Blob([arrayBuffer], {\n        type: response.headers.get('content-type')\n      });\n      const file = new File([blob], 'demo-track.mp3', {\n        type: 'audio/mpeg'\n      });\n      await audioProcessor.initFile(file);\n      nowPlaying.textContent = 'Demo Track';\n\n      // Update audio state\n      isAudioPlaying = true;\n      currentAudioType = 'demo';\n\n      // Add play/pause control\n      addPlayPauseControl();\n      console.log(\"Demo track initialized\");\n    } catch (error) {\n      console.error('Error playing demo track:', error);\n      alert('Error playing demo track: ' + error.message);\n      nowPlaying.textContent = 'Error: Demo Track Failed';\n    }\n  }\n\n  /**\r\n   * Restart the current audio source\r\n   * Useful when something breaks and you need to reset the audio system\r\n   */\n  function restartCurrentSource() {\n    // Only if we have an active audio type\n    if (currentAudioType) {\n      // Save the current type\n      const savedType = currentAudioType;\n\n      // Stop everything\n      if (audioProcessor.isActive) {\n        audioProcessor.stop();\n      }\n\n      // Wait a tiny bit for the audio context to reset\n      setTimeout(() => {\n        // Restart with the same source type\n        switchAudioSource(savedType);\n      }, 100);\n    }\n  }\n});\n\n//# sourceURL=webpack://reverb-xr/./src/main.js?");

/***/ }),

/***/ "./src/scripts/SpotifyAPIHandler.js":
/*!******************************************!*\
  !*** ./src/scripts/SpotifyAPIHandler.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SpotifyAPIHandler: () => (/* binding */ SpotifyAPIHandler)\n/* harmony export */ });\n/**\r\n * Handles all Spotify API interactions\r\n * Separates API concerns from audio processing\r\n */\nclass SpotifyAPIHandler {\n  constructor() {\n    this.clientId = window.APP_CONFIG?.SPOTIFY_CLIENT_ID || '';\n    this.redirectUri = window.location.origin + '/callback.html';\n    this.accessToken = null;\n    this.isAuthorized = false;\n    this.currentTrack = null;\n    this.playbackInterval = null;\n    this.playbackCallback = null;\n\n    // Validate configuration\n    if (!this.clientId) {\n      console.error('Spotify Client ID not configured. Spotify integration will not work.');\n    } else {\n      console.log('Spotify Client ID loaded successfully');\n    }\n\n    // Check if we're returning from an auth flow\n    this.checkAuth();\n  }\n\n  /**\r\n   * Start the Spotify authorization flow\r\n   */\n  authorize() {\n    // Generate a random state value for security\n    const state = this.generateRandomString(16);\n    localStorage.setItem('spotify_auth_state', state);\n\n    // Define the scopes needed for your application\n    const scope = 'user-read-playback-state user-read-currently-playing user-modify-playback-state';\n\n    // Redirect to Spotify authorization page\n    window.location.href = 'https://accounts.spotify.com/authorize' + '?response_type=token' + '&client_id=' + encodeURIComponent(this.clientId) + '&scope=' + encodeURIComponent(scope) + '&redirect_uri=' + encodeURIComponent(this.redirectUri) + '&state=' + encodeURIComponent(state);\n  }\n\n  /**\r\n   * Check if we have a valid auth token\r\n   * @returns {boolean} Whether we're authorized\r\n   */\n  checkAuth() {\n    const params = this.getHashParams();\n    const storedState = localStorage.getItem('spotify_auth_state');\n    if (params.access_token && (params.state == null || params.state === storedState)) {\n      this.accessToken = params.access_token;\n      this.isAuthorized = true;\n\n      // Clear the hash parameters from the URL\n      window.history.replaceState({}, document.title, window.location.pathname);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\r\n   * Register a callback to receive track updates\r\n   * @param {Function} callback Function to call with track updates\r\n   */\n  onPlaybackUpdate(callback) {\n    this.playbackCallback = callback;\n  }\n\n  /**\r\n   * Begin monitoring Spotify playback\r\n   */\n  startPlaybackMonitoring() {\n    // Check immediately\n    this.getCurrentPlayback();\n\n    // Then check every 3 seconds\n    this.playbackInterval = setInterval(() => {\n      this.getCurrentPlayback();\n    }, 3000);\n  }\n\n  /**\r\n   * Stop monitoring playback state\r\n   */\n  stopPlaybackMonitoring() {\n    if (this.playbackInterval) {\n      clearInterval(this.playbackInterval);\n      this.playbackInterval = null;\n    }\n  }\n\n  /**\r\n   * Check if Spotify has an active device\r\n   * @returns {Promise<boolean>} Whether a device is active\r\n   */\n  async hasActiveDevice() {\n    if (!this.isAuthorized) return false;\n    try {\n      const response = await fetch('https://api.spotify.com/v1/me/player', {\n        headers: {\n          'Authorization': `Bearer ${this.accessToken}`\n        }\n      });\n      return response.status !== 204;\n    } catch (error) {\n      console.error('Error checking for active device:', error);\n      return false;\n    }\n  }\n\n  /**\r\n   * Get the current playback state from Spotify\r\n   */\n  async getCurrentPlayback() {\n    if (!this.isAuthorized) {\n      return this.notifyPlaybackUpdate(null, 'Not authorized');\n    }\n    try {\n      const response = await fetch('https://api.spotify.com/v1/me/player', {\n        headers: {\n          'Authorization': `Bearer ${this.accessToken}`\n        }\n      });\n      if (response.status === 204) {\n        // No active device\n        return this.notifyPlaybackUpdate(null, 'No active Spotify playback');\n      }\n      if (!response.ok) {\n        throw new Error(`HTTP error ${response.status}`);\n      }\n      const data = await response.json();\n      if (!data.item) {\n        return this.notifyPlaybackUpdate(null, 'Nothing playing');\n      }\n\n      // Update the current track info\n      this.currentTrack = {\n        name: data.item.name,\n        artist: data.item.artists.map(a => a.name).join(', '),\n        album: data.item.album.name,\n        albumArt: data.item.album.images[0]?.url,\n        isPlaying: data.is_playing,\n        uri: data.item.uri\n      };\n\n      // Notify any listeners\n      this.notifyPlaybackUpdate(this.currentTrack, this.currentTrack.isPlaying ? 'Now Playing' : 'Paused');\n      return this.currentTrack;\n    } catch (error) {\n      console.error('Error fetching current playback:', error);\n      return this.notifyPlaybackUpdate(null, 'Error fetching playback');\n    }\n  }\n\n  /**\r\n   * Notify callback about playback updates\r\n   * @param {Object|null} track Track information\r\n   * @param {string} status Status message\r\n   */\n  notifyPlaybackUpdate(track, status) {\n    if (this.playbackCallback) {\n      this.playbackCallback(track, status);\n    }\n    return track;\n  }\n\n  /**\r\n   * Toggle play/pause state\r\n   */\n  async togglePlayback() {\n    if (!this.isAuthorized) return false;\n    try {\n      // Get current state first\n      const response = await fetch('https://api.spotify.com/v1/me/player', {\n        headers: {\n          'Authorization': `Bearer ${this.accessToken}`\n        }\n      });\n      if (response.status === 204) {\n        alert('No active Spotify device found. Start playing in your Spotify app first.');\n        return false;\n      }\n      if (!response.ok) {\n        throw new Error(`HTTP error ${response.status}`);\n      }\n      const data = await response.json();\n      const isPlaying = data.is_playing;\n\n      // Send the opposite command\n      await fetch(`https://api.spotify.com/v1/me/player/${isPlaying ? 'pause' : 'play'}`, {\n        method: 'PUT',\n        headers: {\n          'Authorization': `Bearer ${this.accessToken}`\n        }\n      });\n\n      // Update immediately\n      setTimeout(() => this.getCurrentPlayback(), 500);\n      return !isPlaying; // Return the new state\n    } catch (error) {\n      console.error('Error toggling playback:', error);\n      return false;\n    }\n  }\n\n  /**\r\n   * Resume playback\r\n   */\n  async play() {\n    if (!this.isAuthorized) return false;\n    try {\n      await fetch('https://api.spotify.com/v1/me/player/play', {\n        method: 'PUT',\n        headers: {\n          'Authorization': `Bearer ${this.accessToken}`\n        }\n      });\n\n      // Update immediately\n      setTimeout(() => this.getCurrentPlayback(), 500);\n      return true;\n    } catch (error) {\n      console.error('Error resuming Spotify playback:', error);\n      return false;\n    }\n  }\n\n  /**\r\n   * Pause playback\r\n   */\n  async pause() {\n    if (!this.isAuthorized) return false;\n    try {\n      await fetch('https://api.spotify.com/v1/me/player/pause', {\n        method: 'PUT',\n        headers: {\n          'Authorization': `Bearer ${this.accessToken}`\n        }\n      });\n\n      // Update immediately\n      setTimeout(() => this.getCurrentPlayback(), 500);\n      return true;\n    } catch (error) {\n      console.error('Error pausing Spotify playback:', error);\n      return false;\n    }\n  }\n\n  /**\r\n   * Skip to next track\r\n   */\n  async nextTrack() {\n    if (!this.isAuthorized) return false;\n    try {\n      await fetch('https://api.spotify.com/v1/me/player/next', {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.accessToken}`\n        }\n      });\n\n      // Wait a moment for Spotify to update\n      setTimeout(() => this.getCurrentPlayback(), 500);\n      return true;\n    } catch (error) {\n      console.error('Error skipping to next track:', error);\n      return false;\n    }\n  }\n\n  /**\r\n   * Skip to previous track\r\n   */\n  async previousTrack() {\n    if (!this.isAuthorized) return false;\n    try {\n      await fetch('https://api.spotify.com/v1/me/player/previous', {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.accessToken}`\n        }\n      });\n\n      // Wait a moment for Spotify to update\n      setTimeout(() => this.getCurrentPlayback(), 500);\n      return true;\n    } catch (error) {\n      console.error('Error skipping to previous track:', error);\n      return false;\n    }\n  }\n\n  /**\r\n   * Search for tracks\r\n   * @param {string} query Search term\r\n   * @returns {Promise<Object>} Search results\r\n   */\n  async searchTracks(query) {\n    if (!this.isAuthorized) return {\n      tracks: {\n        items: []\n      }\n    };\n    try {\n      const response = await fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=track&limit=10`, {\n        headers: {\n          'Authorization': `Bearer ${this.accessToken}`\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`HTTP error ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error searching tracks:', error);\n      return {\n        tracks: {\n          items: []\n        }\n      };\n    }\n  }\n\n  /**\r\n   * Play a specific track by URI\r\n   * @param {string} uri Track URI\r\n   */\n  async playTrack(uri) {\n    if (!this.isAuthorized) return false;\n    try {\n      await fetch('https://api.spotify.com/v1/me/player/play', {\n        method: 'PUT',\n        headers: {\n          'Authorization': `Bearer ${this.accessToken}`\n        },\n        body: JSON.stringify({\n          uris: [uri]\n        })\n      });\n\n      // Update immediately\n      setTimeout(() => this.getCurrentPlayback(), 500);\n      return true;\n    } catch (error) {\n      console.error('Error playing track:', error);\n      return false;\n    }\n  }\n\n  // Helper method to parse hash parameters\n  getHashParams() {\n    const hashParams = {};\n    let e,\n      r = /([^&;=]+)=?([^&;]*)/g,\n      q = window.location.hash.substring(1);\n    while (e = r.exec(q)) {\n      hashParams[e[1]] = decodeURIComponent(e[2]);\n    }\n    return hashParams;\n  }\n\n  // Generate a random string for the state parameter\n  generateRandomString(length) {\n    let text = '';\n    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    for (let i = 0; i < length; i++) {\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n    return text;\n  }\n\n  /**\r\n   * Clean up resources\r\n   */\n  cleanup() {\n    this.stopPlaybackMonitoring();\n  }\n\n  /**\r\n   * Simple hash function to convert a string to a numeric seed\r\n   * @param {string} str Input string\r\n   * @returns {number} Hash value\r\n   */\n  hashString(str) {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      hash = (hash << 5) - hash + str.charCodeAt(i);\n      hash |= 0; // Convert to 32bit integer\n    }\n    return hash;\n  }\n}\n\n//# sourceURL=webpack://reverb-xr/./src/scripts/SpotifyAPIHandler.js?");

/***/ }),

/***/ "./src/scripts/audio/AudioProcessor.js":
/*!*********************************************!*\
  !*** ./src/scripts/audio/AudioProcessor.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioProcessor: () => (/* binding */ AudioProcessor)\n/* harmony export */ });\n/* harmony import */ var _InitializedState_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./InitializedState.js */ \"./src/scripts/audio/InitializedState.js\");\n\nclass AudioProcessor {\n  constructor(options = {}) {\n    // limit to one instance for whole scope\n    if (AudioProcessor.instance) {\n      return AudioProcessor.instance;\n    }\n    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    this.analyser = this.audioContext.createAnalyser();\n    this.analyser.fftSize = 2048;\n    this.analyser.smoothingTimeConstant = 0.8;\n    this.bufferLength = this.analyser.frequencyBinCount;\n    this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);\n    this.state = new _InitializedState_js__WEBPACK_IMPORTED_MODULE_0__.InitializedState(this.audioContext, this.analyser);\n    this.isActive = false;\n    this.isPlaying = true;\n    this.source = null;\n    this.startTime = null;\n    this.debugMode = options.debugMode || false;\n    AudioProcessor.instance = this;\n  }\n  static getInstance() {\n    if (!AudioProcessor.instance) {\n      AudioProcessor.instance = new AudioProcessor();\n    }\n    return AudioProcessor.instance;\n  }\n  async play() {\n    this.isPlaying = true;\n    this.audioContext.resume();\n  }\n  async pause() {\n    this.isPlaying = false;\n    this.audioContext.suspend();\n  }\n  async initMicrophone() {\n    if (!this.isActive) {\n      this.state = await this.state.initMicrophone();\n      this.isActive = true;\n      this.audioContext.resume();\n      if (this.debugMode) {\n        console.log('initMicrophone');\n      }\n    } else {\n      if (this.debugMode) {\n        console.log('already active');\n      }\n    }\n  }\n  async initFile(file) {\n    if (!this.isActive) {\n      this.state = await this.state.initFile(file);\n      this.isActive = true;\n      this.audioContext.resume();\n      if (this.debugMode) {\n        console.log('initFile:', file.name);\n      }\n    } else {\n      if (this.debugMode) {\n        console.log('already active');\n      }\n    }\n  }\n  initMockData() {\n    if (!this.isActive) {\n      this.state = this.state.initMockData();\n      this.isActive = true;\n      this.audioContext.resume();\n      if (this.debugMode) {\n        console.log('initMockData');\n      }\n    } else {\n      if (this.debugMode) {\n        console.log('already active');\n      }\n    }\n  }\n  stop() {\n    if (this.isActive) {\n      this.state = this.state.stop();\n      this.isActive = false;\n      if (this.debugMode) {\n        console.log('Audio processing stopped');\n      }\n    } else {\n      if (this.debugMode) {\n        console.log('already inactive');\n      }\n    }\n  }\n\n  /**\r\n   * Set debug mode for the audio processor\r\n   * Controls logging, analyzer settings, and processing behavior\r\n   * \r\n   * @param {boolean} enabled - Whether debug mode should be enabled\r\n   */\n  setDebugMode(enabled) {\n    // Store the previous value to detect changes\n    const previousMode = this.debugMode;\n\n    // Update the flag\n    this.debugMode = enabled;\n\n    // If this is a mode change, log it\n    if (previousMode !== enabled) {\n      console.log(`Debug mode ${enabled ? 'enabled' : 'disabled'}`);\n\n      // Adjust analyzer settings for debug mode\n      if (enabled) {\n        // In debug mode, use more precise settings for better diagnostic data\n        this.analyser.smoothingTimeConstant = 0.5; // Less smoothing for more responsive debugging\n\n        // Log current state\n        console.log('Audio processor state:', {\n          isActive: this.isActive,\n          isPlaying: this.isPlaying,\n          fftSize: this.analyser.fftSize,\n          smoothingTimeConstant: this.analyser.smoothingTimeConstant,\n          bufferLength: this.bufferLength\n        });\n      } else {\n        // In production mode, optimize for performance\n        this.analyser.smoothingTimeConstant = 0.8; // More smoothing for better visual quality\n      }\n    }\n\n    // If we have an active connection, logging information about it\n    if (this.isActive && enabled) {\n      console.log('Active audio connection with current state:', this.state);\n    }\n  }\n\n  // TODO: Check if active for below functions\n  getFrequencyData() {\n    this._normalizeFrequencyData(this.state.getFrequencyData(this.dataArray));\n    return this.dataArray;\n  }\n  getTimeDomainData() {\n    this._normalizeTimeDomainData(this.state.getTimeDomainData(this.dataArray));\n    return this.dataArray;\n  }\n  getFrequencyDataForAPI() {\n    this._normalizeFrequencyData(this.getFrequencyData(), this.dataArray);\n    return this.dataArray.slice();\n  }\n  getTimeDomainDataForAPI() {\n    this._normalizeTimeDomainData(this.getTimeDomainData(), this.dataArray);\n    return this.dataArray.slice();\n  }\n  getFrequencyBinCount() {\n    return this.analyser.frequencyBinCount;\n  }\n\n  /**\r\n   * Helper function to normalize frequency data from dB (-100 to 0) to 0-255 range\r\n   * @param {Float32Array} sourceData - Raw frequency data (typically -100 to 0 dB)\r\n   * @param {Uint8Array} targetArray - Target array for normalized values\r\n   * @private\r\n   */\n  _normalizeFrequencyData(sourceData, targetArray) {\n    for (let i = 0; i < sourceData.length; i++) {\n      // Frequency data is typically in -100 to 0 dB range\n      // Map to 0-255 range, where -100dB = 0 and 0dB = 255\n      const normalizedValue = (sourceData[i] + 100) / 100;\n      targetArray[i] = Math.floor(Math.max(0, Math.min(255, normalizedValue * 255)));\n    }\n  }\n\n  /**\r\n   * Helper function to normalize time domain data from -1,1 to 0-255 range\r\n   * @param {Float32Array} sourceData - Raw time domain data (-1 to 1)\r\n   * @param {Uint8Array} targetArray - Target array for normalized values\r\n   * @private\r\n   */\n  _normalizeTimeDomainData(sourceData, targetArray) {\n    for (let i = 0; i < sourceData.length; i++) {\n      // Time domain data is in -1 to 1 range\n      // Map -1.0 to 1.0 to 0-255 range\n      const normalizedValue = (sourceData[i] + 1) / 2;\n      targetArray[i] = Math.floor(Math.max(0, Math.min(255, normalizedValue * 255)));\n    }\n  }\n}\n\n//# sourceURL=webpack://reverb-xr/./src/scripts/audio/AudioProcessor.js?");

/***/ }),

/***/ "./src/scripts/audio/GPUAudioProcessor.js":
/*!************************************************!*\
  !*** ./src/scripts/audio/GPUAudioProcessor.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GPUAudioProcessor: () => (/* binding */ GPUAudioProcessor)\n/* harmony export */ });\n/* harmony import */ var _AudioProcessor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AudioProcessor.js */ \"./src/scripts/audio/AudioProcessor.js\");\n\n/**\r\n * GPUAudioProcessor - Audio analysis class with WebGL/THREE.js integration\r\n * Handles audio input sources and converts audio data to GPU-friendly formats\r\n */\nclass GPUAudioProcessor extends _AudioProcessor_js__WEBPACK_IMPORTED_MODULE_0__.AudioProcessor {\n  /**\r\n   * Create a new GPUAudioProcessor\r\n   * @param {Object} options - Configuration options\r\n   * @param {number} [options.fftSize=2048] - FFT size for frequency analysis\r\n   * @param {number} [options.smoothingTimeConstant=0.8] - Smoothing factor for analysis\r\n   * @param {boolean} [options.debugMode=false] - Enable console debugging output\r\n   */\n  constructor(options = {}) {\n    super(); // Call parent constructor to initialize base state\n\n    // Get the audio context and analyzer from the parent class\n    this.audioCtx = this.audioContext;\n    this.analyser = this.analyser;\n\n    // Update analyzer with provided options\n    if (options.fftSize) this.analyser.fftSize = options.fftSize;\n    if (options.smoothingTimeConstant) this.analyser.smoothingTimeConstant = options.smoothingTimeConstant;\n\n    // Create data buffers for GPU-specific formats (Float32 vs Uint8 in base class)\n    this.frequencyBinCount = this.analyser.frequencyBinCount;\n    this.frequencyData = new Float32Array(this.frequencyBinCount);\n    this.timeDomainData = new Float32Array(this.frequencyBinCount);\n\n    // For debugging\n    this.debugMode = options.debugMode || false;\n\n    // Create data textures for WebGL\n    this.frequencyDataTexture = this.createDataTexture(this.frequencyData);\n    this.timeDomainDataTexture = this.createDataTexture(this.timeDomainData);\n  }\n\n  /**\r\n   * Creates a THREE.js texture from audio data\r\n   * @param {Float32Array} data - Audio data to convert to texture\r\n   * @returns {THREE.DataTexture} Texture containing the audio data\r\n   */\n  createDataTexture(data) {\n    const texture = new THREE.DataTexture(data, data.length, 1, THREE.RedFormat, THREE.FloatType);\n    texture.needsUpdate = true;\n    return texture;\n  }\n\n  /**\r\n   * Updates the internal textures with fresh audio data\r\n   * Called each frame to get new audio analysis\r\n   * Side-effects: Updates frequencyData, timeDomainData, and their textures\r\n   */\n  updateTextureData() {\n    // Get fresh data\n    this.analyser.getFloatFrequencyData(this.frequencyData);\n    this.analyser.getFloatTimeDomainData(this.timeDomainData);\n    this.frequencyDataTexture.needsUpdate = true;\n    this.timeDomainDataTexture.needsUpdate = true;\n  }\n\n  /**\r\n   * Initializes microphone input\r\n   * Overrides base class method to add GPU-specific handling\r\n   * @returns {Promise<void>} Promise that resolves when mic is initialized\r\n   */\n  async initMicrophone() {\n    // Call the base class implementation to handle state transitions\n    await super.initMicrophone();\n\n    // Get fresh data for our GPU textures\n    this.updateTextureData();\n    if (this.debugMode) {\n      console.log('GPU-enhanced microphone initialized');\n    }\n  }\n\n  /**\r\n   * Initializes audio from a file\r\n   * Overrides base class method to add GPU-specific handling\r\n   * @param {File} file - The audio file to play\r\n   * @returns {Promise<void>} Promise that resolves when file is initialized\r\n   */\n  async initFile(file) {\n    // Call the base class implementation to handle state transitions\n    await super.initFile(file);\n\n    // Get fresh data for our GPU textures\n    this.updateTextureData();\n    if (this.debugMode) {\n      console.log('GPU-enhanced file playback initialized');\n    }\n  }\n\n  /**\r\n   * Initializes audio from a URL (for demo or preset audio)\r\n   * New GPU-specific method not in base class\r\n   * @param {string} url - The URL of the audio file to play\r\n   * @returns {Promise<void>} Promise that resolves when audio starts playing\r\n   */\n  async initFromUrl(url) {\n    // Fetch and decode the audio data\n    try {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`HTTP error! Status: ${response.status}`);\n      }\n      const arrayBuffer = await response.arrayBuffer();\n      const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);\n\n      // Create and set up a source using equivalent of initFile\n      // This simulates a file being loaded but from a URL\n      const file = new File([arrayBuffer], \"audio-from-url.mp3\", {\n        type: \"audio/mpeg\"\n      });\n      await this.initFile(file);\n      if (this.debugMode) {\n        console.log('Playing audio from URL:', url);\n      }\n    } catch (err) {\n      console.error('Error loading audio from URL:', err);\n    }\n  }\n\n  /**\r\n   * Stops any currently playing audio source\r\n   * Overrides base class method to add GPU-specific cleanup\r\n   */\n  stop() {\n    // Call the base class implementation to handle state transitions\n    super.stop();\n\n    // Clear our GPU textures or reset them to default values\n    this.frequencyData.fill(0);\n    this.timeDomainData.fill(0);\n    this.frequencyDataTexture.needsUpdate = true;\n    this.timeDomainDataTexture.needsUpdate = true;\n    if (this.debugMode) {\n      console.log('GPU audio processing stopped');\n    }\n  }\n\n  /**\r\n   * Pauses the current audio source\r\n   * Overrides base class method\r\n   */\n  async pause() {\n    // Call the base class implementation\n    await super.pause();\n    if (this.debugMode) {\n      console.log('GPU audio processing paused');\n    }\n  }\n\n  /**\r\n   * Resumes the current audio source\r\n   * Overrides base class method\r\n   */\n  async play() {\n    // Call the base class implementation\n    await super.play();\n    if (this.debugMode) {\n      console.log('GPU audio processing resumed');\n    }\n  }\n\n  /**\r\n   * @deprecated Use stop() instead\r\n   */\n  stopCurrentSource() {\n    console.warn('stopCurrentSource() is deprecated, use stop() instead');\n    this.stop();\n  }\n\n  /**\r\n   * @deprecated Use pause() instead\r\n   */\n  pauseCurrentSource() {\n    console.warn('pauseCurrentSource() is deprecated, use pause() instead');\n    this.pause();\n  }\n\n  /**\r\n   * @deprecated Use play() instead\r\n   */\n  resumeCurrentSource() {\n    console.warn('resumeCurrentSource() is deprecated, use play() instead');\n    this.play();\n  }\n\n  /**\r\n   * Returns raw frequency domain data\r\n   * @returns {Float32Array} Frequency data in decibels (typically -100 to 0 dB)\r\n   */\n  getFrequencyData() {\n    return this.frequencyData;\n  }\n\n  /**\r\n   * Returns raw time domain data\r\n   * @returns {Float32Array} Time domain data (values between -1 and 1)\r\n   */\n  getTimeDomainData() {\n    // Make sure we have the latest data\n    this.analyser.getFloatTimeDomainData(this.timeDomainData);\n    return this.timeDomainData;\n  }\n\n  /**\r\n   * Returns the frequency data texture for use in shaders\r\n   * @returns {THREE.DataTexture} Texture containing frequency data\r\n   */\n  getFrequencyDataTexture() {\n    return this.frequencyDataTexture;\n  }\n\n  /**\r\n   * Returns the time domain data texture for use in shaders\r\n   * @returns {THREE.DataTexture} Texture containing time domain data\r\n   */\n  getTimeDomainDataTexture() {\n    return this.timeDomainDataTexture;\n  }\n\n  /**\r\n   * Cleans up all resources used by this processor\r\n   * Should be called when the processor is no longer needed\r\n   */\n  dispose() {\n    // First stop any active audio\n    this.stop();\n\n    // Clean up WebGL resources\n    if (this.frequencyDataTexture) {\n      this.frequencyDataTexture.dispose();\n      this.frequencyDataTexture = null;\n    }\n    if (this.timeDomainDataTexture) {\n      this.timeDomainDataTexture.dispose();\n      this.timeDomainDataTexture = null;\n    }\n\n    // The base class manages the AudioContext cleanup\n    // so we don't need to close it manually\n\n    if (this.debugMode) {\n      console.log('GPU audio processor resources disposed');\n    }\n  }\n\n  /**\r\n   * Connects an external analyzer node instead of the internal one\r\n   * @param {AnalyserNode} analyser - Web Audio analyzer node to use\r\n   */\n  connectExternalAnalyser(analyser) {\n    this.analyser = analyser;\n    console.log('Connected external analyzer');\n  }\n\n  /**\r\n   * Sets the volume of the audio output\r\n   * @param {number} volume - Volume level between 0 and 1\r\n   */\n  setVolume(volume) {\n    // Get the current state\n    const currentState = this.state;\n\n    // Use a more moderate scaling curve - square root for more audible range at low volumes\n    // This makes lower volume settings more usable while still providing good control\n    const scaledVolume = Math.sqrt(volume);\n\n    // Store the current volume value for reference\n    this.volume = volume;\n\n    // Call the state's setVolume method if available\n    if (currentState && typeof currentState.setVolume === 'function') {\n      // The state will handle all volume implementation\n      // Pass the original volume, not the scaled volume, to avoid double-scaling\n      currentState.setVolume(volume);\n\n      // Log for debugging\n      console.log('Volume set via state method:', volume, 'Scaled volume (not used):', scaledVolume);\n\n      // We've delegated volume control to the state, so no need to also do it here\n      // This prevents double-application of volume changes\n      return;\n    }\n\n    // Fallback: If state doesn't have a setVolume method, handle it here\n    if (currentState && currentState.gainNode) {\n      // If the state has a gain node, use it\n      currentState.gainNode.gain.value = volume === 0 ? 0 : Math.max(0.0001, scaledVolume);\n      console.log('Volume set directly on state gain node:', volume, 'Applied gain:', currentState.gainNode.gain.value);\n    } else if (this.gainNode) {\n      // Use our local gain node as fallback\n      this.gainNode.gain.value = volume === 0 ? 0 : Math.max(0.0001, scaledVolume);\n      console.log('Volume set on processor gain node:', volume, 'Applied gain:', this.gainNode.gain.value);\n    } else {\n      // Create a gain node if none exists\n      this.gainNode = this.audioContext.createGain();\n      this.gainNode.gain.value = volume === 0 ? 0 : Math.max(0.0001, scaledVolume);\n\n      // Connect through the state system if possible\n      if (this.analyser) {\n        try {\n          this.analyser.disconnect();\n          this.analyser.connect(this.gainNode);\n          this.gainNode.connect(this.audioContext.destination);\n          console.log('Created new gain node and set up connections');\n        } catch (e) {\n          console.error('Error setting up gain node:', e);\n        }\n      }\n      console.log('Created new gain node with volume:', volume, 'Applied gain:', this.gainNode.gain.value);\n    }\n    if (this.debugMode) {\n      console.log('Volume set to:', volume, 'Scaled volume:', scaledVolume);\n    }\n  }\n\n  /**\r\n   * Updates the internal analyzer settings and recreates data buffers\r\n   * Should be called after changing FFT size or other analyzer settings\r\n   */\n  updateAnalyzerSettings() {\n    // Get the current fft size and smoothing\n    const fftSize = this.analyser.fftSize;\n    const smoothingTimeConstant = this.analyser.smoothingTimeConstant;\n\n    // Store current values to restore after setup\n    this.fftSize = fftSize;\n    this.smoothingTimeConstant = smoothingTimeConstant;\n\n    // Update our data buffers after analyzer settings change\n    this.frequencyBinCount = this.analyser.frequencyBinCount;\n    this.frequencyData = new Float32Array(this.frequencyBinCount);\n    this.timeDomainData = new Float32Array(this.frequencyBinCount);\n\n    // Recreate textures with new size\n    if (this.frequencyDataTexture) {\n      this.frequencyDataTexture.dispose();\n    }\n    if (this.timeDomainDataTexture) {\n      this.timeDomainDataTexture.dispose();\n    }\n    this.frequencyDataTexture = this.createDataTexture(this.frequencyData);\n    this.timeDomainDataTexture = this.createDataTexture(this.timeDomainData);\n    if (this.debugMode) {\n      console.log(`Analyzer settings updated: fftSize=${fftSize}, smoothing=${smoothingTimeConstant}`);\n    }\n  }\n\n  /**\r\n   * Set the FFT size for frequency analysis\r\n   * @param {number} size - Must be a power of 2 between 32 and 32768\r\n   */\n  setFFTSize(size) {\n    // Ensure size is a valid FFT size (power of 2)\n    const validSizes = [32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768];\n    if (!validSizes.includes(size)) {\n      console.error('FFT size must be a power of 2 between 32 and 32768');\n      return;\n    }\n\n    // Set the size on the analyzer\n    this.analyser.fftSize = size;\n\n    // Update our buffers and textures\n    this.updateAnalyzerSettings();\n  }\n\n  /**\r\n   * @deprecated Use getFrequencyDataTexture() and getTimeDomainDataTexture() instead\r\n   */\n  reconnectAnalyzer(connectToOutput = true) {\n    console.warn('reconnectAnalyzer() is deprecated as it may interfere with state management');\n    // Legacy implementation maintained for backward compatibility\n    try {\n      this.analyser.disconnect();\n      if (connectToOutput) {\n        if (this.gainNode) {\n          this.analyser.connect(this.gainNode);\n          this.gainNode.connect(this.audioContext.destination);\n        } else {\n          this.analyser.connect(this.audioContext.destination);\n        }\n      }\n    } catch (e) {\n      console.error('Error in reconnectAnalyzer:', e);\n    }\n  }\n\n  /**\r\n   * @deprecated Use the state pattern methods instead\r\n   */\n  setupAnalyser() {\n    console.warn('setupAnalyser() is deprecated as it may interfere with state management');\n    this.updateAnalyzerSettings();\n  }\n\n  /**\r\n   * @deprecated Use updateAnalyzerSettings() instead\r\n   */\n  ensureAudioContext() {\n    console.warn('ensureAudioContext() is deprecated. Use updateAnalyzerSettings() instead');\n    // Forward to play() which handles resuming the AudioContext\n    this.play();\n  }\n\n  /**\r\n   * Override the base class getFrequencyDataForAPI method to use our Float32 data\r\n   * @returns {Uint8Array} Normalized frequency data in 0-255 range\r\n   */\n  getFrequencyDataForAPI() {\n    // Update our Float32 data first\n    this.analyser.getFloatFrequencyData(this.frequencyData);\n\n    // Then convert to Uint8Array format for API compatibility\n    const uint8Array = new Uint8Array(this.frequencyBinCount);\n    this._normalizeFrequencyData(this.frequencyData, uint8Array);\n    if (this.debugMode && uint8Array.length > 0) {\n      console.log(\"Converted frequency data sample:\", Array.from(uint8Array.slice(0, 5)));\n    }\n    return uint8Array;\n  }\n\n  /**\r\n   * Override the base class getTimeDomainDataForAPI method to use our Float32 data\r\n   * @returns {Uint8Array} Normalized time domain data in 0-255 range\r\n   */\n  getTimeDomainDataForAPI() {\n    // Update our Float32 data first\n    this.analyser.getFloatTimeDomainData(this.timeDomainData);\n\n    // Then convert to Uint8Array format for API compatibility\n    const uint8Array = new Uint8Array(this.frequencyBinCount);\n    this._normalizeTimeDomainData(this.timeDomainData, uint8Array);\n    return uint8Array;\n  }\n\n  /**\r\n   * Helper function to normalize frequency data from dB (-100 to 0) to 0-255 range\r\n   * @param {Float32Array} sourceData - Raw frequency data (typically -100 to 0 dB)\r\n   * @param {Uint8Array} targetArray - Target array for normalized values\r\n   * @private\r\n   */\n  _normalizeFrequencyData(sourceData, targetArray) {\n    for (let i = 0; i < this.frequencyBinCount; i++) {\n      // Frequency data is typically in -100 to 0 dB range\n      // Map to 0-255 range, where -100dB = 0 and 0dB = 255\n      const normalizedValue = (sourceData[i] + 100) / 100;\n      targetArray[i] = Math.floor(Math.max(0, Math.min(255, normalizedValue * 255)));\n    }\n  }\n\n  /**\r\n   * Helper function to normalize time domain data from -1,1 to 0-255 range\r\n   * @param {Float32Array} sourceData - Raw time domain data (-1 to 1)\r\n   * @param {Uint8Array} targetArray - Target array for normalized values\r\n   * @private\r\n   */\n  _normalizeTimeDomainData(sourceData, targetArray) {\n    for (let i = 0; i < this.frequencyBinCount; i++) {\n      // Time domain data is in -1 to 1 range\n      // Map -1.0 to 1.0 to 0-255 range\n      const normalizedValue = (sourceData[i] + 1) / 2;\n      targetArray[i] = Math.floor(Math.max(0, Math.min(255, normalizedValue * 255)));\n    }\n  }\n\n  /**\r\n   * Initializes mock data for testing\r\n   * Overrides base class method\r\n   */\n  initMockData() {\n    // Call the base class implementation\n    super.initMockData();\n\n    // Update our GPU textures\n    this.updateTextureData();\n    if (this.debugMode) {\n      console.log('GPU-enhanced mock data initialized');\n    }\n  }\n}\n\n//# sourceURL=webpack://reverb-xr/./src/scripts/audio/GPUAudioProcessor.js?");

/***/ }),

/***/ "./src/scripts/audio/InitializedState.js":
/*!***********************************************!*\
  !*** ./src/scripts/audio/InitializedState.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InitializedState: () => (/* binding */ InitializedState)\n/* harmony export */ });\n// Remove the circular imports at the top\n// import { FileState } from \"./FileState.js\";\n// import { MicrophoneState } from \"./MicrophoneState.js\";\n// import { NetworkStreamState } from \"./NetworkStreamState.js\";\n\n/**\r\n * Base audio state that handles common functionality and state transitions.\r\n * All specific audio state implementations should extend this class.\r\n */\nclass InitializedState {\n  constructor(audioContext, analyser) {\n    this.audioContext = audioContext;\n    this.analyser = analyser;\n    this.source = null;\n\n    // Create a gain node by default for all audio states\n    this.gainNode = this.audioContext.createGain();\n    // Default to full volume\n    this.gainNode.gain.value = 1.0;\n\n    // Connect analyzer to gain node by default\n    // Child classes should use this.gainNode in their setup\n    try {\n      this.analyser.connect(this.gainNode);\n      this.gainNode.connect(this.audioContext.destination);\n    } catch (e) {\n      console.error('Error setting up default gain node:', e);\n    }\n  }\n\n  /**\r\n   * Sets the volume for this audio state\r\n   * @param {number} volume - Volume level between 0 and 1\r\n   */\n  setVolume(volume) {\n    if (!this.gainNode) {\n      this.gainNode = this.audioContext.createGain();\n      try {\n        // Reconnect if needed\n        this.analyser.connect(this.gainNode);\n        this.gainNode.connect(this.audioContext.destination);\n      } catch (e) {\n        console.error('Error setting up gain node in setVolume:', e);\n      }\n    }\n\n    // Use square root scaling for more natural volume control\n    // This gives more audible range at low volume settings, while still allowing for fine control\n    const scaledVolume = Math.sqrt(volume);\n\n    // Set the gain value - ensure 0 is actually 0, otherwise use scaled value\n    this.gainNode.gain.value = volume === 0 ? 0 : scaledVolume;\n    console.log('Base state volume set to:', volume, 'Scaled volume:', scaledVolume);\n  }\n\n  /**\r\n   * Initializes microphone input\r\n   * @returns {Promise<MicrophoneState>} Promise that resolves to new state\r\n   */\n  async initMicrophone() {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      const source = this.audioContext.createMediaStreamSource(stream);\n      source.connect(this.analyser);\n\n      // Use dynamic import to avoid circular dependency\n      const {\n        MicrophoneState\n      } = await __webpack_require__.e(/*! import() */ \"src_scripts_audio_MicrophoneState_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./MicrophoneState.js */ \"./src/scripts/audio/MicrophoneState.js\"));\n      return new MicrophoneState(this.audioContext, this.analyser, source, stream);\n    } catch (error) {\n      console.error(\"Error accessing microphone:\", error);\n      return this;\n    }\n  }\n\n  /**\r\n   * Initializes audio from a file\r\n   * @param {File} file - The audio file to play\r\n   * @returns {Promise<FileState>} Promise that resolves to new state\r\n   */\n  async initFile(file) {\n    try {\n      const arrayBuffer = await file.arrayBuffer();\n      const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);\n\n      // Use dynamic import to avoid circular dependency\n      const {\n        FileState\n      } = await __webpack_require__.e(/*! import() */ \"src_scripts_audio_FileState_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./FileState.js */ \"./src/scripts/audio/FileState.js\"));\n      return new FileState(this.audioContext, this.analyser, audioBuffer);\n    } catch (error) {\n      console.error(\"Error loading audio file:\", error);\n      return this;\n    }\n  }\n\n  /**\r\n   * Initializes audio from a network stream\r\n   * @param {string} streamUrl - URL of the stream to play\r\n   * @returns {Promise<NetworkStreamState>} Promise that resolves to new state\r\n   */\n  async initNetworkStream(streamUrl) {\n    try {\n      // Use dynamic import to avoid circular dependency\n      const {\n        NetworkStreamState\n      } = await __webpack_require__.e(/*! import() */ \"src_scripts_audio_NetworkStreamState_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./NetworkStreamState.js */ \"./src/scripts/audio/NetworkStreamState.js\"));\n      return new NetworkStreamState(this.audioContext, this.analyser, streamUrl);\n    } catch (error) {\n      console.error(\"Error initializing network stream:\", error);\n      return this;\n    }\n  }\n\n  /**\r\n   * Creates mock audio data for testing\r\n   * @returns {InitializedState} This state with mock data\r\n   */\n  initMockData() {\n    // Clean up current source if it exists\n    this.stop();\n    this.source = this.audioContext.createBufferSource();\n    const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 3, this.audioContext.sampleRate);\n    const data = buffer.getChannelData(0);\n\n    // Generate mock data (e.g., sine wave or random data)\n    for (let i = 0; i < data.length; i++) {\n      data[i] = Math.random() * 2 - 1; // Random data between -1 and 1\n    }\n    this.source.buffer = buffer;\n    this.source.loop = true;\n    this.source.connect(this.analyser);\n    this.source.start();\n    console.log(\"Mock data initialized\");\n    return this;\n  }\n\n  /**\r\n   * Stops and cleans up the current audio source\r\n   */\n  stop() {\n    if (this.source) {\n      this.source.disconnect();\n      if (this.source.stop) {\n        this.source.stop(0);\n      }\n      this.source = null;\n      console.log(\"Audio source stopped\");\n    }\n  }\n\n  /**\r\n   * Gets frequency data from the analyzer\r\n   * @param {Uint8Array} dataArray - Array to store frequency data\r\n   */\n  getFrequencyData(dataArray) {\n    this.analyser.getByteFrequencyData(dataArray);\n  }\n\n  /**\r\n   * Gets time domain data from the analyzer\r\n   * @param {Uint8Array} dataArray - Array to store time domain data\r\n   */\n  getTimeDomainData(dataArray) {\n    this.analyser.getByteTimeDomainData(dataArray);\n  }\n}\n\n//# sourceURL=webpack://reverb-xr/./src/scripts/audio/InitializedState.js?");

/***/ }),

/***/ "./src/scripts/audio/SpotifyProcessor.js":
/*!***********************************************!*\
  !*** ./src/scripts/audio/SpotifyProcessor.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SpotifyProcessor: () => (/* binding */ SpotifyProcessor)\n/* harmony export */ });\n/* harmony import */ var _AudioProcessor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AudioProcessor.js */ \"./src/scripts/audio/AudioProcessor.js\");\n/* harmony import */ var _SpotifyAPIHandler_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../SpotifyAPIHandler.js */ \"./src/scripts/SpotifyAPIHandler.js\");\n\n\n\n/**\r\n * Audio processor with Spotify integration\r\n * Handles audio processing aspects while delegating API interactions to SpotifyAPIHandler\r\n */\nclass SpotifyProcessor extends _AudioProcessor_js__WEBPACK_IMPORTED_MODULE_0__.AudioProcessor {\n  constructor() {\n    // If AudioProcessor singleton already exists, return it\n    if (_AudioProcessor_js__WEBPACK_IMPORTED_MODULE_0__.AudioProcessor.instance) {\n      // Add spotify properties to existing instance\n      const instance = _AudioProcessor_js__WEBPACK_IMPORTED_MODULE_0__.AudioProcessor.instance;\n      this.enhanceWithSpotify(instance);\n      return instance;\n    }\n\n    // Otherwise create new instance with Spotify capabilities\n    super(); // Initialize AudioProcessor\n    this.enhanceWithSpotify(this);\n\n    // Store the Spotify-enhanced singleton\n    SpotifyProcessor.instance = this;\n  }\n\n  /**\r\n   * Add Spotify capabilities to an AudioProcessor instance\r\n   * @param {AudioProcessor} instance Instance to enhance\r\n   */\n  enhanceWithSpotify(instance) {\n    // Create the Spotify API handler\n    instance.spotifyAPI = new _SpotifyAPIHandler_js__WEBPACK_IMPORTED_MODULE_1__.SpotifyAPIHandler();\n\n    // Set up event listener for playback updates\n    instance.spotifyAPI.onPlaybackUpdate((track, status) => {\n      instance.updateNowPlaying(track, status);\n    });\n\n    // Flag to track Spotify integration\n    instance.hasSpotifyCapabilities = true;\n  }\n\n  /**\r\n   * Get the singleton instance\r\n   * @returns {SpotifyProcessor} The singleton instance\r\n   */\n  static getInstance() {\n    if (!SpotifyProcessor.instance) {\n      SpotifyProcessor.instance = new SpotifyProcessor();\n    }\n    return SpotifyProcessor.instance;\n  }\n\n  /**\r\n   * Start the Spotify authorization flow\r\n   */\n  authorize() {\n    this.spotifyAPI.authorize();\n  }\n\n  /**\r\n   * Check if we have a valid token\r\n   * @returns {boolean} Whether we're authorized\r\n   */\n  checkAuth() {\n    return this.spotifyAPI.isAuthorized;\n  }\n\n  /**\r\n   * Connect to current Spotify playback\r\n   */\n  async connectToSpotify() {\n    if (!this.spotifyAPI.isAuthorized) {\n      console.error('Not authorized with Spotify');\n      return;\n    }\n    try {\n      // Check if there's an active device\n      const hasDevice = await this.spotifyAPI.hasActiveDevice();\n      if (!hasDevice) {\n        alert('No active Spotify device found. Start playing in your Spotify app first.');\n        return;\n      }\n\n      // Set our state to active\n      if (!this.isActive) {\n        this.isActive = true;\n        this.audioContext.resume();\n\n        // Start polling for current track info\n        this.spotifyAPI.startPlaybackMonitoring();\n        console.log('Connected to Spotify playback');\n      }\n    } catch (error) {\n      console.error('Error connecting to Spotify:', error);\n    }\n  }\n\n  /**\r\n   * Override stop to handle Spotify cleanup\r\n   */\n  stop() {\n    // Call the parent class stop method\n    super.stop();\n\n    // Add Spotify-specific cleanup\n    if (this.spotifyAPI) {\n      this.spotifyAPI.stopPlaybackMonitoring();\n    }\n    console.log('Spotify processor stopped');\n  }\n\n  /**\r\n   * Update the UI with current playback info\r\n   * @param {Object|null} track Track information\r\n   * @param {string} status Status message\r\n   */\n  updateNowPlaying(track, status) {\n    const trackNameElement = document.getElementById('spotify-track-name');\n    const trackArtistElement = document.getElementById('spotify-track-artist');\n    const trackAlbumArtElement = document.getElementById('spotify-album-art');\n    const trackStatusElement = document.getElementById('spotify-status');\n    const nowPlayingElement = document.getElementById('now-playing');\n    if (trackNameElement) {\n      trackNameElement.textContent = track ? track.name : 'No track';\n    }\n    if (trackArtistElement) {\n      trackArtistElement.textContent = track ? track.artist : '';\n    }\n    if (trackAlbumArtElement) {\n      if (track && track.albumArt) {\n        trackAlbumArtElement.src = track.albumArt;\n        trackAlbumArtElement.style.display = 'block';\n      } else {\n        trackAlbumArtElement.style.display = 'none';\n      }\n    }\n    if (trackStatusElement) {\n      trackStatusElement.textContent = status;\n    }\n\n    // Also update the main \"Now Playing\" display if system audio is not active\n    const systemAudioOption = document.getElementById('system-audio-option');\n    if (nowPlayingElement && track && (!systemAudioOption || !systemAudioOption.checked)) {\n      nowPlayingElement.textContent = `Spotify: ${track.name} - ${track.artist}`;\n    }\n  }\n\n  /**\r\n   * Overrides the play method from AudioProcessor\r\n   */\n  async play() {\n    await super.play();\n\n    // If we have Spotify integration, also try to resume Spotify playback\n    if (this.spotifyAPI && this.spotifyAPI.isAuthorized && this.spotifyAPI.currentTrack && !this.spotifyAPI.currentTrack.isPlaying) {\n      await this.spotifyAPI.play();\n    }\n  }\n\n  /**\r\n   * Overrides the pause method from AudioProcessor\r\n   */\n  async pause() {\n    await super.pause();\n\n    // If we have Spotify integration, also try to pause Spotify playback\n    if (this.spotifyAPI && this.spotifyAPI.isAuthorized && this.spotifyAPI.currentTrack && this.spotifyAPI.currentTrack.isPlaying) {\n      await this.spotifyAPI.pause();\n    }\n  }\n\n  /**\r\n   * Play/Pause the current track (Toggle)\r\n   */\n  async togglePlayback() {\n    if (!this.spotifyAPI || !this.spotifyAPI.isAuthorized) return;\n    const newIsPlaying = await this.spotifyAPI.togglePlayback();\n\n    // Also update our AudioProcessor state\n    if (newIsPlaying) {\n      await this.play();\n    } else {\n      await this.pause();\n    }\n  }\n\n  /**\r\n   * Skip to next track\r\n   */\n  async nextTrack() {\n    if (this.spotifyAPI) {\n      await this.spotifyAPI.nextTrack();\n    }\n  }\n\n  /**\r\n   * Skip to previous track\r\n   */\n  async previousTrack() {\n    if (this.spotifyAPI) {\n      await this.spotifyAPI.previousTrack();\n    }\n  }\n\n  /**\r\n   * Search for tracks\r\n   * @param {string} query Search term\r\n   * @returns {Promise<Object>} Search results\r\n   */\n  async searchTracks(query) {\n    if (this.spotifyAPI) {\n      return await this.spotifyAPI.searchTracks(query);\n    }\n    return {\n      tracks: {\n        items: []\n      }\n    };\n  }\n\n  /**\r\n   * Play a specific track by URI\r\n   * @param {string} uri Track URI\r\n   */\n  async playTrack(uri) {\n    if (this.spotifyAPI) {\n      await this.spotifyAPI.playTrack(uri);\n    }\n  }\n\n  /**\r\n   * Clean up when done\r\n   */\n  cleanup() {\n    if (this.spotifyAPI) {\n      this.spotifyAPI.cleanup();\n    }\n    this.stop();\n  }\n\n  /**\r\n   * Get frequency data for API\r\n   * @returns {Uint8Array} Frequency data array\r\n   */\n  getFrequencyDataForAPI() {\n    // If we're connected to Spotify and have a current track\n    if (this.spotifyAPI && this.spotifyAPI.isAuthorized && this.spotifyAPI.currentTrack && this.spotifyAPI.currentTrack.isPlaying) {\n      // Generate placeholder data based on the track info\n      this.generateMockAudioData();\n    }\n\n    // Call the base class method to get the data\n    return super.getFrequencyDataForAPI();\n  }\n\n  /**\r\n   * Method to create interesting visualization data\r\n   */\n  generateMockAudioData() {\n    // Create a pseudo-random but consistent pattern for the currently playing track\n    if (!this.spotifyAPI || !this.spotifyAPI.currentTrack) return;\n    const trackId = this.spotifyAPI.currentTrack.name + this.spotifyAPI.currentTrack.artist;\n    const seed = this.spotifyAPI.hashString(trackId);\n\n    // Generate frequency data that looks somewhat musical\n    for (let i = 0; i < this.dataArray.length; i++) {\n      // Create a value based on index, seed, and some oscillations\n      const time = Date.now() / 1000;\n      const value = Math.abs(Math.sin(i * 0.01 + seed * 0.1) * 0.5 + Math.sin(i * 0.05 + time) * 0.3 + Math.sin(time * 2 + i * 0.01) * 0.2);\n\n      // Scale to 0-255 range\n      this.dataArray[i] = Math.floor(value * 255);\n    }\n  }\n}\n\n//# sourceURL=webpack://reverb-xr/./src/scripts/audio/SpotifyProcessor.js?");

/***/ }),

/***/ "./src/scripts/external/spotify-sdk-loader.js":
/*!****************************************************!*\
  !*** ./src/scripts/external/spotify-sdk-loader.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSpotifyPlayer: () => (/* binding */ createSpotifyPlayer),\n/* harmony export */   loadSpotifySDK: () => (/* binding */ loadSpotifySDK)\n/* harmony export */ });\n/**\r\n * Spotify SDK Loader\r\n * This module ensures the Spotify Web Playback SDK is properly loaded\r\n * and the callback function is correctly exposed in a webpack environment\r\n */\n\n/**\r\n * Load the Spotify Web Playback SDK\r\n * @returns {Promise} Promise that resolves when the SDK is ready\r\n */\nfunction loadSpotifySDK() {\n  return new Promise((resolve, reject) => {\n    // Check if SDK is already loaded\n    if (window.Spotify) {\n      console.log('Spotify SDK already loaded');\n      resolve(window.Spotify);\n      return;\n    }\n\n    // Define the callback function that Spotify SDK will call when ready\n    // Explicitly attach to window to ensure it's globally accessible in webpack\n    window.onSpotifyWebPlaybackSDKReady = () => {\n      console.log('Spotify Web Playback SDK is ready');\n      if (window.Spotify) {\n        resolve(window.Spotify);\n      } else {\n        reject(new Error('Spotify SDK loaded but Spotify object not found'));\n      }\n    };\n\n    // Load the SDK script\n    const script = document.createElement('script');\n    script.src = 'https://sdk.scdn.co/spotify-player.js';\n    script.async = true;\n\n    // Handle load errors\n    script.onerror = () => {\n      reject(new Error('Failed to load Spotify SDK'));\n    };\n\n    // Append the script to the document\n    document.body.appendChild(script);\n  });\n}\n\n/**\r\n * Initialize a Spotify Player instance\r\n * @param {string} token - Spotify access token\r\n * @returns {Object} Spotify Player instance\r\n */\nfunction createSpotifyPlayer(token) {\n  if (!window.Spotify) {\n    throw new Error('Spotify SDK not loaded');\n  }\n  return new window.Spotify.Player({\n    name: 'Reverb XR Audio Visualizer',\n    getOAuthToken: cb => cb(token)\n  });\n}\n\n//# sourceURL=webpack://reverb-xr/./src/scripts/external/spotify-sdk-loader.js?");

/***/ }),

/***/ "./src/scripts/utils/pathResolver.js":
/*!*******************************************!*\
  !*** ./src/scripts/utils/pathResolver.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   isDevelopment: () => (/* binding */ isDevelopment),\n/* harmony export */   resolveAssetPath: () => (/* binding */ resolveAssetPath),\n/* harmony export */   resolvePath: () => (/* binding */ resolvePath)\n/* harmony export */ });\n/**\r\n * Path resolver utility for managing URLs in development and production\r\n * Helps with resolving correct paths for assets and pages\r\n */\n\n/**\r\n * Resolves a relative path to handle both development and production environments\r\n * In development, might need to handle paths differently than in production\r\n * \r\n * @param {string} path - The relative path to resolve\r\n * @returns {string} - The resolved path\r\n */\nfunction resolvePath(path) {\n  // Remove leading slash if it exists\n  if (path.startsWith('/')) {\n    path = path.substring(1);\n  }\n\n  // In production, paths will be relative to the root\n  // In development with webpack-dev-server, paths are also relative to root\n  // This function could be expanded to handle CDN paths or other scenarios\n\n  return path;\n}\n\n/**\r\n * Resolves an asset path (images, sounds, etc)\r\n * \r\n * @param {string} path - The relative path to the asset\r\n * @returns {string} - The resolved asset path\r\n */\nfunction resolveAssetPath(path) {\n  // For assets, we may want different handling\n  return 'assets/' + path.replace(/^assets\\//, '');\n}\n\n/**\r\n * Detects if the app is running in development or production mode\r\n * \r\n * @returns {boolean} - True if running in development\r\n */\nfunction isDevelopment() {\n  // Check if webpack's development flag is set\n  // For webpack 5, we need to check if the process object exists first\n  try {\n    // This will be replaced by webpack's DefinePlugin\n    return typeof process !== 'undefined' && process.env && \"development\" !== 'production';\n  } catch (e) {\n    // If process is not defined (or some other error), assume development\n    return true;\n  }\n}\n\n// Export a default object with all utilities\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  resolvePath,\n  resolveAssetPath,\n  isDevelopment\n});\n\n//# sourceURL=webpack://reverb-xr/./src/scripts/utils/pathResolver.js?");

/***/ }),

/***/ "./src/styles/main.css":
/*!*****************************!*\
  !*** ./src/styles/main.css ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_main_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./main.css */ \"./node_modules/css-loader/dist/cjs.js!./src/styles/main.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_main_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_main_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_main_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_main_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://reverb-xr/./src/styles/main.css?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		id: moduleId,
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/******/ // expose the modules object (__webpack_modules__)
/******/ __webpack_require__.m = __webpack_modules__;
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/ensure chunk */
/******/ (() => {
/******/ 	__webpack_require__.f = {};
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = (chunkId) => {
/******/ 		return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 			__webpack_require__.f[key](chunkId, promises);
/******/ 			return promises;
/******/ 		}, []));
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/get javascript chunk filename */
/******/ (() => {
/******/ 	// This function allow to reference async chunks
/******/ 	__webpack_require__.u = (chunkId) => {
/******/ 		// return url for filenames based on template
/******/ 		return "" + chunkId + ".bundle.js";
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/import chunk loading */
/******/ (() => {
/******/ 	// no baseURI
/******/ 	
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// [resolve, Promise] = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"main": 0
/******/ 	};
/******/ 	
/******/ 	var installChunk = (data) => {
/******/ 		var {__webpack_ids__, __webpack_modules__, __webpack_runtime__} = data;
/******/ 		// add "modules" to the modules object,
/******/ 		// then flag all "ids" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0;
/******/ 		for(moduleId in __webpack_modules__) {
/******/ 			if(__webpack_require__.o(__webpack_modules__, moduleId)) {
/******/ 				__webpack_require__.m[moduleId] = __webpack_modules__[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(__webpack_runtime__) __webpack_runtime__(__webpack_require__);
/******/ 		for(;i < __webpack_ids__.length; i++) {
/******/ 			chunkId = __webpack_ids__[i];
/******/ 			if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				installedChunks[chunkId][0]();
/******/ 			}
/******/ 			installedChunks[__webpack_ids__[i]] = 0;
/******/ 		}
/******/ 	
/******/ 	}
/******/ 	
/******/ 	__webpack_require__.f.j = (chunkId, promises) => {
/******/ 			// import() chunk loading for javascript
/******/ 			var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 			if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 	
/******/ 				// a Promise means "currently loading".
/******/ 				if(installedChunkData) {
/******/ 					promises.push(installedChunkData[1]);
/******/ 				} else {
/******/ 					if(true) { // all chunks have JS
/******/ 						// setup Promise in chunk cache
/******/ 						var promise = import("./" + __webpack_require__.u(chunkId)).then(installChunk, (e) => {
/******/ 							if(installedChunks[chunkId] !== 0) installedChunks[chunkId] = undefined;
/******/ 							throw e;
/******/ 						});
/******/ 						var promise = Promise.race([promise, new Promise((resolve) => (installedChunkData = installedChunks[chunkId] = [resolve]))])
/******/ 						promises.push(installedChunkData[1] = promise);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 	};
/******/ 	
/******/ 	// no prefetching
/******/ 	
/******/ 	// no preloaded
/******/ 	
/******/ 	// no external install chunk
/******/ 	
/******/ 	// no on chunks loaded
/******/ })();
/******/ 
/******/ /* webpack/runtime/nonce */
/******/ (() => {
/******/ 	__webpack_require__.nc = undefined;
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 
